<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRAFKOMMMMMMM</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
    </script>
</head>
<body>
    <div id="info">WASD untuk bergerak, Mouse untuk melihat sekitar, F untuk flashlight, N untuk toggle malam/siang</div>
    <div id="compass" style="position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; background-color: rgba(0, 0, 0, 0.5); padding: 5px; border-radius: 5px;">
  Direction: -
</div>
    <div id="emerald-message" style="position: absolute; top: 60px; left: 10px; color: #ff0000; font-family: monospace; background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 5px; font-size: 18px; z-index: 10;">
   Collect All Emeralds
</div>
    <!-- Tambahkan di dalam <body>, setelah elemen lain -->
<div id="emerald-counter" style="position: absolute; top: 20px; right: 30px; color: #00ff00; font-family: monospace; background: rgba(0,0,0,0.7); padding: 10px 18px; border-radius: 8px; font-size: 22px; z-index: 20; text-align: right;">
  💎 0 / 10
</div>
    
    <script type="module">
        // Import Three.js dari CDN dengan path yang benar
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

        // Variabel global
        let scene, camera, renderer;
        let ground;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let velocity = new THREE.Vector3();
        let prevTime = performance.now();
        const speed = 300.0;

        // Deklarasikan variabel global untuk lampu dan status mode
        let ambientLight, directionalLight;
        let isNight = false;
        
        // Variabel untuk flashlight
        let flashlight;
        let isFlashlightOn = false;

        // Variabel untuk smooth camera movement
        let mouseEnabled = false;
        const mouseVelocity = new THREE.Vector2(0, 0);
        const mouseAcceleration = 0.1;
        const mouseDamping = 0.7;

        // Kontrol kamera
        const cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
        
        // Variabel untuk collision detection
        const collisionObjects = [];
        const playerRadius = 5; // Radius collision player
        const playerHeight = 10; // Tinggi player (untuk staircase jika perlu)
        
        // Ray casting untuk collision
        const raycaster = new THREE.Raycaster();
        
        let isDriving = false;
        let carModel = null;  // Simpan referensi model mobil untuk mode mengemudi
        let carCollisionBox = null;

        let lastPlayerPosition = null;

        // Tambahkan di bagian deklarasi variabel global
        let leftHeadlight, rightHeadlight;

        // Tambahkan variabel global untuk bulan
        let moon;

        // Tambahkan variabel global untuk kecepatan mobil
        let carSpeed = 80; // default

        // Add these global variables at the top
let chaosEmeralds = [];
let emeraldCollisionBoxes = []; // Tambahkan ini
let collectedEmeralds = 0;
const TOTAL_EMERALDS = 10;

        // Add this with other global variables at the top
let flashlightSound;

// Add with other global variables at the top
let carEngineSound;

// Add to global variables at the top
let emeraldCollectSound;

// Add to global variables at the top
let creepySinging;
let isCreepySingingPlaying = false;

// Tambahkan di global variables (di atas)
let creepyTriggered = false;

// Tambahkan variabel global di atas
let emeraldsLoaded = false;

// Tambahkan di bagian variabel global
let horrorImages = [];
let horrorImagesLoaded = false;
let firstEmeraldCollected = false;

// Tambahkan variabel global untuk tracking first time entering car
let firstTimeEnteringCar = true;

// Tambahkan variabel global untuk status ghost
let ghostSpawned = false;

// Inisialisasi scene
        function init() {
            // Membuat scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Membuat kamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1500); // Ubah dari 5000 ke 10000
            // Spawn player di X: -1163, Y: 10, Z: -8
            camera.position.set(-1141, 23, 191);
            camera.rotation.order = 'YXZ';
            
            // Inisialisasi cahaya dengan variabel global
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Directional light (matahari)
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            
            // Atur kualitas dan area shadow untuk directional light
            directionalLight.shadow.mapSize.width = 4096; // Tingkatkan resolusi shadow
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Setup flashlight dengan shadow yang lebih detail
            flashlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);
            flashlight.castShadow = true;
            flashlight.shadow.mapSize.width = 1024;
            flashlight.shadow.mapSize.height = 1024;
            flashlight.shadow.camera.near = 0.5;
            flashlight.shadow.camera.far = 100;
            flashlight.shadow.bias = -0.0001;
            scene.add(flashlight);
            scene.add(flashlight.target);
            
            // Setup headlights untuk mobil
            leftHeadlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);
            rightHeadlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);

            // Setup kedua headlight
            [leftHeadlight, rightHeadlight].forEach(light => {
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                light.shadow.camera.near = 0.5;
                light.shadow.camera.far = 100;
                light.shadow.bias = -0.0001;
                light.visible = false; // Nonaktifkan pada awalnya
                scene.add(light);
                scene.add(light.target);
            });
            
            // Membuat tanah
            createGround();
            
            // Tambahkan road 4 arah
            create4WayRoad();
            
            // Load model hospital
            loadHospitalModel();
            
            // Load model skyscraper
            loadSkyscraperModel();

            // Load model house
            loadHouseModel();

            // Tambahkan batas map untuk collision
            createMapBoundaries();
            
            // Load model car
            loadCarModel();
            
            // Load moon model
            const moonLoader = new GLTFLoader();
            moonLoader.load(
                '/model/moon_idle.glb',
                function (gltf) {
                    moon = gltf.scene;
                    moon.scale.set(5, 5, 5);
                    moon.position.set(-500, 700, 300);
                    
                    // Tambahkan point light untuk bulan
                    const moonLight = new THREE.PointLight(0xc2c5cc, 0.5, 1000);
                    moonLight.position.copy(moon.position);
                    moon.userData.moonLight = moonLight; // Simpan referensi ke moonLight
                    scene.add(moonLight);
                    
                    moon.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshPhongMaterial({
                                map: child.material.map,
                                emissive: 0xffffcc,
                                emissiveIntensity: 0.0, // Akan diubah saat mode malam
                                side: THREE.DoubleSide
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(moon);
                },
                undefined,
                function (error) {
                    console.error('Error loading moon:', error);
                }
            );
            
            // Setup renderer, event listener, dan animasi
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.darkness = 1; // Menambah kegelapan shadow
            document.body.appendChild(renderer.domElement);
            
            // Setup event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            
            // Tambahkan event listener untuk pointer lock
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mozpointerlockchange', onPointerLockChange);
            document.addEventListener('webkitpointerlockchange', onPointerLockChange);
            
            // Request pointer lock on click
            document.body.addEventListener('click', requestPointerLock);
            
            animate();
            loadCathedralModel();
            loadSmallBuildingModel();
            loadBakeryModel();
            loadHungryJacksModel();
            loadPoliceStationModel(); 
            loadWarehouseModel();
            loadStopSign();
            // Panggil fungsi loadTownHouseModel() di akhir init()
            loadTownHouseModel();
            loadBillboardModel();
            loadTungTung();
            loadFarmHouseModel();
            loadWelcomeBoardModel();
            loadOldBuildingModel();
            // loadGhostModel(); // ← comment out or delete this line
            
            // Load Chaos Emerald model
            // loadChaosEmeraldModel();
            initAudio();
            
            // Load horror images
            loadHorrorImages();
        }

        function createFlashlight() {
            // Buat SpotLight untuk flashlight
            flashlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);
            
            // Setel posisi awal dan target spotlight
            flashlight.position.set(0, 0, 0);
            flashlight.target.position.set(0, 0, -1);
            
            // Mengaktifkan bayangan untuk flashlight
            flashlight.castShadow = true;
            flashlight.shadow.mapSize.width = 1024;
            flashlight.shadow.mapSize.height = 1024;
            
            // Nonaktifkan flashlight pada awalnya
            flashlight.visible = false;
            
            // Tambahkan flashlight dan targetnya ke scene
            scene.add(flashlight);
            scene.add(flashlight.target);
        }

        function toggleFlashlight() {
            isFlashlightOn = !isFlashlightOn;
            flashlight.visible = isFlashlightOn;
            
            // Play flashlight sound
            if (flashlightSound) {
                flashlightSound.currentTime = 0; // Reset sound to start
                flashlightSound.play().catch(error => {
                    console.log("Audio play failed:", error);
                });
            }
        }
        
        function playClickSound() {
            // Implementasi Web Audio API untuk efek suara klik
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(isFlashlightOn ? 800 : 600, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                console.error('Web Audio API tidak didukung:', e);
            }
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(2500, 800);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2E8B57,
                side: THREE.DoubleSide
            });
            
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Hapus atau komentari baris berikut untuk menghilangkan garis putih:
            // const gridHelper = new THREE.GridHelper(1000, 50);
            // scene.add(gridHelper);
        }

        // Fungsi untuk membuat bounding box pada objek 3D
        function createCollisionBox(object, offsetX = 0, offsetY = 0, offsetZ = 0, scaleX = 1, scaleY = 1, scaleZ = 1) {
            // Buat bounding box helper untuk visualisasi (opsional, dapat dikomentari untuk produksi)
            // const boxHelper = new THREE.BoxHelper(object, 0xff0000);
            // scene.add(boxHelper);
            
            // Hitung bounding box objek
            const bbox = new THREE.Box3().setFromObject(object);
            
            // Buat custom collision box dengan mesh tak terlihat
            const width = (bbox.max.x - bbox.min.x) * scaleX;
            const height = (bbox.max.y - bbox.min.y) * scaleY;
            const depth = (bbox.max.z - bbox.min.z) * scaleZ;
            
            const collisionGeometry = new THREE.BoxGeometry(width, height, depth);
            const collisionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                wireframe: true,
                visible: false // Set ke true untuk debugging
            });
            
            const collisionMesh = new THREE.Mesh(collisionGeometry, collisionMaterial);
            
            // Posisikan collision box di tengah objek + offset
            collisionMesh.position.set(
                (bbox.min.x + bbox.max.x) / 2 + offsetX,
                (bbox.min.y + bbox.max.y) / 2 + offsetY,
                (bbox.min.z + bbox.max.z) / 2 + offsetZ
            );
            
            scene.add(collisionMesh);
            collisionObjects.push(collisionMesh);
            
            return collisionMesh;
        }

        // Fungsi untuk membuat batas map (invisible walls)
        function createMapBoundaries() {
            // Karena ground 2500 x 1000, setengahnya:
            const mapWidth = 1250  // setengah lebar ground (X)
            const mapHeight = 400  // setengah panjang ground (Z)
            const wallHeight = 100
            const wallThickness = 10

            // Buat material transparan untuk dinding
            const wallMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.0, // Tidak terlihat
                side: THREE.DoubleSide
            });

            // Dinding Utara (Z negatif)
            const northWallGeometry = new THREE.BoxGeometry(mapWidth * 2, wallHeight, wallThickness);
            const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
            northWall.position.set(0, wallHeight / 2, -mapHeight);
            scene.add(northWall);
            collisionObjects.push(northWall);

            // Dinding Selatan (Z positif)
            const southWall = northWall.clone();
            southWall.position.set(0, wallHeight / 2, mapHeight);
            scene.add(southWall);
            collisionObjects.push(southWall);

            // Dinding Barat (X negatif)
            const westWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, mapHeight * 2);
            const westWall = new THREE.Mesh(westWallGeometry, wallMaterial);
            westWall.position.set(-mapWidth, wallHeight / 2, 0);
            scene.add(westWall);
            collisionObjects.push(westWall);

            // Dinding Timur (X positif)
            const eastWall = westWall.clone();
            eastWall.position.set(mapWidth, wallHeight / 2, 0);
            scene.add(eastWall);
            collisionObjects.push(eastWall);
        }

        async function loadHospitalModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/low_poly_hospital.glb');
                
                const hospital = gltf.scene;
                hospital.position.set(-216, 0.1, -229);
                hospital.scale.set(11, 11, 11);
                hospital.rotation.y = 0;
                
                hospital.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Tambahkan material properties untuk shadow yang lebih baik
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });
                
                scene.add(hospital);
                createCollisionBox(hospital, 0, 10, 0, 1, 1, 0.8);
            } catch (error) {
                console.error('Gagal memuat model rumah sakit:', error);
                createSimpleHospital();
            }
        }

        async function loadSkyscraperModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Skyscraper.glb');
                const skyscraper = gltf.scene;
                skyscraper.position.set(215, 0.1, -213);
                skyscraper.scale.set(200, 200, 200);
                skyscraper.rotation.y = Math.PI;

                skyscraper.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Tambahkan material properties untuk shadow yang lebih baik
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(skyscraper);
                createCollisionBox(skyscraper, 0, 10, 0, 1, 1, 1);
            } catch (error) {
                console.error('Gagal memuat model skyscraper:', error);
            }
        }

        async function loadHouseModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/House with driveway.glb');
                const house = gltf.scene;
                // Tempatkan house pada X: -1123, Z: 209
                house.position.set(-1139, 0.1, 220);
                house.scale.set(10, 10, 10); // Sesuaikan skala jika perlu
                house.rotation.y = Math.PI; // Rotasi jika perlu

                house.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                scene.add(house);

                // Tambahkan collision box untuk house jika perlu
                createCollisionBox(house, 0, 20, 0, 1, 1, 0.14);
            } catch (error) {
                console.error('Gagal memuat model house:', error);
            }
        }

        async function loadCarModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/1994_Nissan_180MX.glb');
                const car = gltf.scene;
                car.position.set(-1163, 13, 30);
                car.scale.set(6, 6, 6);
                car.rotation.y = Math.PI / 2;

                car.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Tambahkan material properties untuk shadow yang lebih baik
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(car);
                carModel = car;
                // HAPUS atau COMMENT collision box mobil agar tidak ada collision sama sekali
                // carCollisionBox = createCollisionBox(car, 0, 10, 0, 1, 1, 1);
            } catch (error) {
                console.error('Error loading car model:', error);
            }
        }

        function createSimpleHospital() {
            // Fallback: create a simple red box as a hospital model substitute
            const geometry = new THREE.BoxGeometry(1000, 10, 10);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const simpleHospital = new THREE.Mesh(geometry, material);
            simpleHospital.position.set(50, 5, 50);
            simpleHospital.castShadow = true;
            simpleHospital.receiveShadow = true;
            scene.add(simpleHospital);
            
            // Tambahkan collision untuk fallback hospital
            collisionObjects.push(simpleHospital);
        }

        function create4WayRoad() {
            const roadColor = 0x333333;
            const roadMaterial = new THREE.MeshStandardMaterial({ color: roadColor });
            const groundSize = 2500; // same size as the ground
            const roadWidth = 100; // road width
        
            // Horizontal road (along X axis)
            const horizontalGeometry = new THREE.PlaneGeometry(groundSize, roadWidth);
            const horizontalRoad = new THREE.Mesh(horizontalGeometry, roadMaterial);
            horizontalRoad.rotation.x = -Math.PI / 2;
            horizontalRoad.position.set(0, 0.11, 0);
        
            // Hapus/komentari bagian vertical road (arah north-south)
            // const verticalGeometry = new THREE.PlaneGeometry(roadWidth, groundSize);
            // const verticalRoad = new THREE.Mesh(verticalGeometry, roadMaterial);
            // verticalRoad.rotation.x = -Math.PI / 2;
            // verticalRoad.position.set(0, 0.11, 0);
        
            // Create a group to hold the road(s)
            const roadGroup = new THREE.Group();
            roadGroup.add(horizontalRoad);
            // Jangan tambahkan verticalRoad ke group
            // roadGroup.add(verticalRoad);
            roadGroup.position.set(0, 0, 0);
        
            scene.add(roadGroup);
        }
        function createSimpleStreetlamps() {
            const spacing = 150;
            const roadWidth = 100;
            const roadLength = 1000;
            const offsetFromRoadCenter = roadWidth / 2 + 5;
            
            // Create global array to manage streetlamp lights
            if (!window.streetLampLights) window.streetLampLights = [];
            
            // Create simple lamps on north side
            for (let x = -roadLength; x <= roadLength; x += spacing) {
                // Create lamp post (cylinder)
                const postGeometry = new THREE.CylinderGeometry(1, 1, 40, 8);
                const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(x, 20, -offsetFromRoadCenter);
                post.castShadow = true;
                scene.add(post);
                
                // Create lamp head (sphere)
                const headGeometry = new THREE.SphereGeometry(3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffeeaa,
                    emissive: 0xffeeaa,
                    emissiveIntensity: isNight ? 1.0 : 0.0
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(x, 48, -offsetFromRoadCenter); // Updated to Y=48 for correct lightbulb position
                head.userData.isLampBulb = true;
                scene.add(head);
                
                // Only add actual light to every 3rd lamp
                if (Math.abs(x) % (spacing * 3) === 0) {
                    const light = new THREE.PointLight(0xffeeaa, 1.5, 150);
                    light.position.set(x, 48, -offsetFromRoadCenter); // Updated to Y=48
                    light.visible = isNight;
                    light.castShadow = false;
                    scene.add(light);
                    window.streetLampLights.push(light);
                }
                
                // Add collision
                createCollisionBox(post, 0, 20, 0, 1, 1, 1);
            }
            
            // Create simple lamps on south side
            for (let x = -roadLength; x <= roadLength; x += spacing) {
                // Create lamp post (cylinder)
                const postGeometry = new THREE.CylinderGeometry(1, 1, 40, 8);
                const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(x, 20, offsetFromRoadCenter);
                post.castShadow = true;
                scene.add(post);
                
                // Create lamp head (sphere)
                const headGeometry = new THREE.SphereGeometry(3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffeeaa,
                    emissive: 0xffeeaa,
                    emissiveIntensity: isNight ? 1.0 : 0.0
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(x, 48, offsetFromRoadCenter); // Updated to Y=48 for correct lightbulb position
                head.userData.isLampBulb = true;
                scene.add(head);
                
                // Only add actual light to every 3rd lamp
                if (Math.abs(x) % (spacing * 3) === 0) {
                    const light = new THREE.PointLight(0xffeeaa, 1.5, 150);
                    light.position.set(x, 48, offsetFromRoadCenter); // Updated to Y=48
                    light.visible = isNight;
                    light.castShadow = false;
                    scene.add(light);
                    window.streetLampLights.push(light);
                }
                
                // Add collision
                createCollisionBox(post, 0, 20, 0, 1, 1, 1);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyN': // Toggle mode malam/siang
                    isNight = !isNight;
                    toggleNightMode();
                    break;
                case 'KeyF': // Toggle flashlight
                    toggleFlashlight();
                    break;
                case 'KeyE':
            if (!isDriving && carModel) {
                // Hitung jarak hanya pada X dan Z
                const dx = camera.position.x - carModel.position.x;
                const dz = camera.position.z - carModel.position.z;
                const distanceXZ = Math.sqrt(dx*dx + dz*dz);
                
                console.log("Jarak ke mobil:", distanceXZ); // Untuk debugging
                
                if (distanceXZ < 30) { // Perbesar jarak deteksi
                    enterCar();
                } else {
                    console.log("Terlalu jauh dari mobil");
                }
            } else if (isDriving) {
                exitCar();
            }
            break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        // Fungsi ini dipanggil saat status pointer lock berubah
        function onPointerLockChange() {
            if (document.pointerLockElement === document.body ||
                document.mozPointerLockElement === document.body ||
                document.webkitPointerLockElement === document.body) {
                mouseEnabled = true;
            } else {
                mouseEnabled = false;
            }
        }

        // Fungsi untuk request pointer lock dengan cross-browser support
        function requestPointerLock() {
            if (!mouseEnabled) {
                const element = document.body;
                
                element.requestPointerLock = element.requestPointerLock ||
                                            element.mozRequestPointerLock ||
                                            element.webkitRequestPointerLock;
                
                element.requestPointerLock();
            }
        }

        // Update fungsi onMouseMove untuk smooth camera
        function onMouseMove(event) {
            if (!mouseEnabled) return;
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            // Batasi input maksimum untuk menghindari gerakan ekstrim
            const maxMovement = 15;
            const clampedMovementX = Math.max(Math.min(movementX, maxMovement), -maxMovement);
            const clampedMovementY = Math.max(Math.min(movementY, maxMovement), -maxMovement);
            
            // Gunakan acceleration yang lebih rendah untuk mouse movement
            mouseVelocity.x -= clampedMovementX * mouseAcceleration;
            mouseVelocity.y -= clampedMovementY * mouseAcceleration;
        }

        function toggleNightMode() {
            if (isNight) {
                // Mode malam: background gelap dan intensitas cahaya sangat rendah
                scene.background = new THREE.Color(0x000001); // Make it even darker
                ambientLight.intensity = 0.02; // Even less ambient light
                directionalLight.intensity = 0.05; // Much less directional light
                directionalLight.position.set(-100, 50, -50);
                
                // Make fog MUCH thicker for horror atmosphere
                scene.fog = new THREE.FogExp2(0x000000, 0.003); // Increased from 0.0007 to 0.003
                
                // Turn on all streetlamp lights but make them dimmer and flickering
                if (window.streetLampLights) {
                    window.streetLampLights.forEach(light => {
                        light.visible = true;
                        light.castShadow = true;
                        light.intensity = 0.8; // Dimmer streetlights
                    });
                }
                
                // Make all lamp bulbs glow but dimmer
                scene.traverse(object => {
                    if (object.isMesh && object.userData.isLampBulb) {
                        if (object.material) {
                            object.material.emissiveIntensity = 0.6; // Dimmer glow
                        }
                    }
                });
                
                // Dim moon lighting
                if (moon) {
                    moon.traverse((child) => {
                        if (child.isMesh) {
                            child.material.emissiveIntensity = 0.5; // Dimmer moon
                        }
                    });
                    if (moon.userData.moonLight) {
                        moon.userData.moonLight.intensity = 0.3; // Much dimmer moonlight
                    }
                }
                
                // Enhanced shadow settings for horror
                renderer.shadowMap.darkness = 0.95; // Much darker shadows
                directionalLight.shadow.bias = -0.001;
                directionalLight.shadow.normalBias = 0.03;
                
                // Enhanced flashlight shadow settings
                [flashlight, leftHeadlight, rightHeadlight].forEach(light => {
                    if (light) {
                        light.shadow.bias = -0.001;
                        light.shadow.normalBias = 0.03;
                        light.shadow.radius = 8; // Softer, more ominous shadows
                        light.penumbra = 0.8; // Much softer light edges
                    }
                });
                
                checkCreepySoundTrigger();
                
                if (firstEmeraldCollected && !ghostSpawned) {
                    console.log("Spawning ghost - night mode + emerald collected!");
                    loadGhostModel();
                    ghostSpawned = true;
                }
                
            } else {
                // Kembali ke mode siang: background dan intensitas normal
                scene.background = new THREE.Color(0x87CEEB);
                ambientLight.intensity = 0.5;
                directionalLight.intensity = 0.8;
                directionalLight.position.set(100, 100, 50);
                scene.fog = null;
                
                if (window.streetLampLights) {
                    window.streetLampLights.forEach(light => {
                        light.visible = false;
                        light.castShadow = false;
                    });
                }
                
                scene.traverse(object => {
                    if (object.isMesh && object.userData.isLampBulb) {
                        if (object.material) {
                            object.material.emissiveIntensity = 0.0;
                        }
                    }
                });
                
                if (moon) {
                    moon.traverse((child) => {
                        if (child.isMesh) {
                            child.material.emissiveIntensity = 0.0;
                        }
                    });
                    if (moon.userData.moonLight) {
                        moon.userData.moonLight.intensity = 0;
                    }
                }
                
                renderer.shadowMap.darkness = 0.3;
                directionalLight.shadow.bias = -0.0001;
                directionalLight.shadow.normalBias = 0.01;
                
                [flashlight, leftHeadlight, rightHeadlight].forEach(light => {
                    if (light) {
                        light.shadow.bias = -0.0001;
                        light.shadow.normalBias = 0.01;
                        light.shadow.radius = 2;
                        light.penumbra = 0.2;
                    }
                });
            }
        }

        
        // Fungsi untuk efek flicker pada flashlight (opsional)
        function flickerFlashlight() {
            if (!isFlashlightOn) return;
            
            // Horror flickering - reduced frequency
            if (isNight && Math.random() < 0.03) { // Reduced from 0.12 to 0.03 (75% less flickering)
                const originalIntensity = 100;
                
                // More dramatic intensity variations
                const flickerIntensity = originalIntensity * (0.1 + Math.random() * 0.4);
                flashlight.intensity = flickerIntensity;
                
                // Also flicker headlights when driving
                if (isDriving) {
                    leftHeadlight.intensity = flickerIntensity;
                    rightHeadlight.intensity = flickerIntensity;
                }
                
                // Random flicker duration for more horror effect
                const flickerDuration = 30 + Math.random() * 150;
                
                setTimeout(() => {
                    flashlight.intensity = originalIntensity;
                    if (isDriving) {
                        leftHeadlight.intensity = 100;
                        rightHeadlight.intensity = 100;
                    }
                }, flickerDuration);
                
                // Occasional complete blackout for maximum horror (reduced frequency)
                if (Math.random() < 0.01) { // Reduced from 0.03 to 0.01
                    flashlight.intensity = 0;
                    if (isDriving) {
                        leftHeadlight.intensity = 0;
                        rightHeadlight.intensity = 0;
                    }
                    
                    setTimeout(() => {
                        flashlight.intensity = originalIntensity;
                        if (isDriving) {
                            leftHeadlight.intensity = 100;
                            rightHeadlight.intensity = 100;
                        }
                    }, 200 + Math.random() * 500); // Blackout for 200-700ms
                }
            } else if (!isNight && Math.random() < 0.005) { // Reduced from 0.02 to 0.005
                const originalIntensity = 100;
                flashlight.intensity = originalIntensity * (0.7 + Math.random() * 0.3);
                
                setTimeout(() => {
                    flashlight.intensity = originalIntensity;
                }, 50 + Math.random() * 100);
            }
        }

        // FIX CAR MOVEMENT - Update the animate function car driving section
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            // Add flickering effects
            flickerFlashlight();
            flickerStreetLights();

            if (isDriving && carModel) {
                // Ambil arah depan dan kanan dari kamera (hanya XZ)
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();

                // WASD untuk arah relatif kamera
                let driveDirection = new THREE.Vector3();
                if (moveForward) driveDirection.add(forward);
                if (moveBackward) driveDirection.sub(forward);
                if (moveLeft) driveDirection.sub(right);
                if (moveRight) driveDirection.add(right);
                driveDirection.normalize();

                // Hitung posisi yang direncanakan
                const plannedPosition = carModel.position.clone().addScaledVector(driveDirection, carSpeed * delta);

                // HAPUS atau COMMENT bagian collision check
                // Cek collision sebelum memindahkan mobil
                // if (!checkCarCollisions(plannedPosition)) {
                    // Tidak ada collision, update posisi mobil
                    carModel.position.copy(plannedPosition);

                    // Update posisi collision box mobil (jika ada)
                    if (carCollisionBox) {
                        carCollisionBox.position.copy(carModel.position);
                    }
                // } else {
                //     // Ada collision, mobil tidak bergerak
                //     console.log("Car collision detected!");
                // }

                // Tambahkan rotasi mobil saat belok
                if (moveLeft || moveRight) {
                    // Tentukan arah rotasi: kiri negatif, kanan positif
                    let turnDirection = 0;
                    if (moveLeft) turnDirection -= 1;
                    if (moveRight) turnDirection += 1;

                    // Atur kecepatan rotasi (radian per detik)
                    const turnSpeed = 1.5; // semakin besar semakin cepat belok

                    // Update rotasi Y mobil
                    carModel.rotation.y -= turnDirection * turnSpeed * delta;
                }

                updateCarCamera();
            } else {
                // Walking mode: update camera rotation and position based on mouse input and collision
                if (mouseEnabled) {
                    mouseVelocity.x *= mouseDamping;
                    mouseVelocity.y *= mouseDamping;
                    if (Math.abs(mouseVelocity.x) < 0.001) mouseVelocity.x = 0;
                    if (Math.abs(mouseVelocity.y) < 0.001) mouseVelocity.y = 0;
                    cameraRotation.y += mouseVelocity.x * delta * 1.5;
                    cameraRotation.x += mouseVelocity.y * delta * 1.5;
                    cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                    camera.rotation.x = cameraRotation.x;
                    camera.rotation.y = cameraRotation.y;
                }
                
                // Update player movement and collision
                let moveDirection = new THREE.Vector3();
                if (moveForward) moveDirection.z += 1;
                if (moveBackward) moveDirection.z -= 1;
                if (moveLeft) moveDirection.x -= 1;
                if (moveRight) moveDirection.x += 1;
                moveDirection.normalize();

                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();
                const move = new THREE.Vector3();
                move.addScaledVector(forward, moveDirection.z * speed * delta);
                move.addScaledVector(right, moveDirection.x * speed * delta);
                
                moveWithCollision(move);
            }
            
            // Update flashlight, kompas, dll.
            if (isFlashlightOn) {
                const forwardDirection = new THREE.Vector3();
                camera.getWorldDirection(forwardDirection);
                
                if (isDriving && carModel) {
                    // Saat driving mode, tempatkan flashlight di depan mobil
                    const offsetY = 5; // Ketinggian lampu dari tanah
                    const offsetZ = 20; // Jarak lampu dari depan mobil
                    
                    // Gunakan posisi mobil sebagai referensi
                    flashlight.position.copy(carModel.position);
                    flashlight.position.y += offsetY;
                    flashlight.position.x += 20; // Sesuaikan dengan arah mobil (ke arah X positif)
                    
                    // Arahkan flashlight ke depan mobil
                    const targetDistance = 30;
                    flashlight.target.position.copy(flashlight.position);
                    flashlight.target.position.x += targetDistance;
                    flashlight.target.updateMatrixWorld();
                } else {
                    // Mode berjalan normal (kode yang sudah ada)
                    const offsetY = -1;
                    flashlight.position.copy(camera.position);
                    flashlight.position.y += offsetY;
                    const targetDistance = 10;
                    flashlight.target.position.copy(camera.position).add(forwardDirection.multiplyScalar(targetDistance));
                    flashlight.target.position.y += offsetY;
                    flashlight.target.updateMatrixWorld();
                }
            }
            
            // Update flashlight untuk lampu mobil
            if (isFlashlightOn) {
                if (isDriving && carModel) {
                    // Nonaktifkan flashlight utama saat driving
                    flashlight.visible = false;

                    // Offset headlight relatif terhadap posisi mobil
                    const offsetY = 5; // Ketinggian lampu
                    const offsetX = 5; // Jarak horizontal antar lampu
                    const forwardOffset = 25.8; // Jarak ke depan dari mobil

                    // Ambil arah depan mobil dari rotasi mobil
                    const carForward = new THREE.Vector3(0, 0, 1).applyEuler(carModel.rotation).normalize();
                    const carRight = new THREE.Vector3(1, 0, 0).applyEuler(carModel.rotation).normalize();

                    // Posisi headlight kiri
                    leftHeadlight.position.copy(carModel.position)
                        .add(carForward.clone().multiplyScalar(forwardOffset))
                        .add(carRight.clone().multiplyScalar(-offsetX))
                        .add(new THREE.Vector3(0, offsetY, 0));
                    leftHeadlight.visible = true;

                    // Posisi headlight kanan
                    rightHeadlight.position.copy(carModel.position)
                        .add(carForward.clone().multiplyScalar(forwardOffset))
                        .add(carRight.clone().multiplyScalar(offsetX))
                        .add(new THREE.Vector3(0, offsetY, 0));
                    rightHeadlight.visible = true;

                    // Target headlight ke depan mobil
                    const targetDistance = 30;
                    leftHeadlight.target.position.copy(leftHeadlight.position).add(carForward.clone().multiplyScalar(targetDistance));
                    rightHeadlight.target.position.copy(rightHeadlight.position).add(carForward.clone().multiplyScalar(targetDistance));
                    leftHeadlight.target.updateMatrixWorld();
                    rightHeadlight.target.updateMatrixWorld();
                } else {
                    // Mode berjalan normal
                    const offsetY = -1;
                    const offsetX = 10;
                    flashlight.position.copy(camera.position);
                    flashlight.position.y += offsetY;
                    flashlight.position.x += offsetX;
                    const targetDistance = 10;
                    const forwardDirection = new THREE.Vector3();
                    camera.getWorldDirection(forwardDirection);
                    flashlight.target.position.copy(camera.position).add(forwardDirection.multiplyScalar(targetDistance));
                    flashlight.target.position.y += offsetY;
                    flashlight.target.position.x += offsetX;
                    flashlight.target.updateMatrixWorld();
                    
                    // Nonaktifkan headlight mobil
                    leftHeadlight.visible = false;
                    rightHeadlight.visible = false;
                }
            } else {
                // Nonaktifkan semua lampu
                leftHeadlight.visible = false;
                rightHeadlight.visible = false;
            }
            
            // Putar bulan perlahan
            if (moon) {
                moon.rotation.y += 0.001;
            }
            
            // Animate ghost floating effect
            if (window.ghostModel) {
                const time = performance.now() * 0.001;
                window.ghostModel.position.y = 5 + Math.sin(time * 2) * 3; // Floating up and down
                window.ghostModel.rotation.y += 0.005; // Slow rotation
            }
            
            updateCompass();
            
            prevTime = time;

            // Tambahkan di dalam fungsi animate(), sebelum renderer.render(scene, camera);
for (let i = 0; i < chaosEmeralds.length; i++) {
    const emerald = chaosEmeralds[i];
    if (emerald) {
        // Efek berputar
        emerald.rotation.y += 1.5 * delta;

        // Efek floating naik-turun
        const baseY = emerald.userData.baseY !== undefined ? emerald.userData.baseY : emerald.position.y;
        emerald.position.y = baseY + Math.sin(time * 0.002 + i) * 2;
        emerald.userData.baseY = baseY;

        // Update posisi emeraldCollisionBoxes jika masih ada
        if (emeraldCollisionBoxes[i]) {
            emeraldCollisionBoxes[i].position.copy(emerald.position);
        }
    }
}

// Panggil checkEmeraldCollection() di akhir animate()
checkEmeraldCollection();
checkCreepySoundTrigger();

            renderer.render(scene, camera);
            
            const infoEl = document.getElementById('info');
            infoEl.innerHTML = `WASD untuk bergerak, Mouse untuk melihat sekitar, F untuk flashlight, N untuk toggle malam/siang, E untuk masuk/keluar mobil<br>
            Kamera Posisi: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`;
        }

        init();

        function initAudio() {
            // Create audio element for flashlight sound
            flashlightSound = new Audio('/audio/sfx/ytmp3free.cc_flashlight-sound-effect-sfx-youtubemp3free.org.mp3');
            flashlightSound.volume = 0.5; // Adjust volume as needed

            // Add car engine sound
            carEngineSound = new Audio('/audio/sfx/ytmp3free.cc_sound-effect-suara-mobil-car-engine-sound-effect-youtubemp3free.org.mp3');
            carEngineSound.volume = 0.3; // Adjust volume as needed
            
            // Add emerald collect sound
            emeraldCollectSound = new Audio('/audio/sfx/ytmp3free.cc_sonic-ring-sound-effect-hd-youtubemp3free.org.mp3');
            emeraldCollectSound.volume = 0.4; // Adjust volume as needed
            
            // Add creepy singing sound
            creepySinging = new Audio('/audio/sfx/ytmp3free.cc_creepy-little-girl-singing-lalala-scary-horror-voice-hd-free-youtubemp3free.org.mp3');
            creepySinging.volume = 0.3;
            creepySinging.loop = true; // Enable looping
        }

        function updateCompass() {
            // Dapatkan rotasi kamera (hanya yaw, pitch tidak dipakai)
            let yawDeg = THREE.MathUtils.radToDeg(camera.rotation.y);
            // Normalisasi ke [0, 360)
            yawDeg = (yawDeg % 360 + 360) % 360;
            
            let cardinal = '';
            if (yawDeg >= 337.5 || yawDeg < 22.5) {
                cardinal = 'N';
            } else if (yawDeg >= 22.5 && yawDeg < 67.5) {
                cardinal = 'NE';
            } else if (yawDeg >= 67.5 && yawDeg < 112.5) {
                cardinal = 'E';
            } else if (yawDeg >= 112.5 && yawDeg < 157.5) {
                cardinal = 'SE';
            } else if (yawDeg >= 157.5 && yawDeg < 202.5) {
                cardinal = 'S';
            } else if (yawDeg >= 202.5 && yawDeg < 247.5) {
                cardinal = 'SW';
            } else if (yawDeg >= 247.5 && yawDeg < 292.5) {
                cardinal = 'W';
            } else if (yawDeg >= 292.5 && yawDeg < 337.5) {
                cardinal = 'NW';
            }
            
            // Update tampilan kompas
            document.getElementById('compass').innerText = 'Direction: ' + cardinal;
        }

        // Update fungsi enterCar()
        function enterCar() {
            isDriving = true;
            // Simpan posisi kamera player sebelum masuk mobil
            lastPlayerPosition = camera.position.clone();

            // Set kecepatan mobil lebih tinggi saat driving mode
            carSpeed = 80; // misal 250, bisa diubah sesuai keinginan

            // Play car engine sound once
            if (carEngineSound) {
                carEngineSound.currentTime = 0; // Reset to start
                carEngineSound.play().catch(error => {
                    console.log("Audio play failed:", error);
                });
            }

            // Check if this is first time entering car
            if (firstTimeEnteringCar) {
                firstTimeEnteringCar = false; // Set flag to false
                if (!isNight) { // Only toggle if not already night
                    isNight = true;
                    toggleNightMode();
                }
            }

            updateCarCamera();
            console.log("Masuk mode mengemudi");
        }

        function exitCar() {
            isDriving = false;

            // Kembalikan kecepatan ke default saat keluar mobil
            carSpeed = 80;

            // Simpan referensi ke rotasi mobil
            const carDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(carModel.quaternion);
            
            // Tempatkan pemain di belakang mobil (relatif terhadap orientasi mobil)
            const offset = carDirection.clone().multiplyScalar(-20); // 20 unit di belakang mobil
            
            // Tempatkan player di belakang mobil, sedikit lebih tinggi
            const newPosition = carModel.position.clone().add(offset).add(new THREE.Vector3(0, 10, 0));
            camera.position.copy(newPosition);
            
            // Hadapkan pemain ke arah mobil
            camera.lookAt(carModel.position);
            
            // Perbarui rotasi kamera agar sesuai dengan lookAt
            cameraRotation.y = camera.rotation.y;
            cameraRotation.x = camera.rotation.x;
            
            // Perbarui lastPlayerPosition
            lastPlayerPosition = newPosition.clone();
            
            console.log("Keluar mode mengemudi");
        }

        function updateCarCamera() {
            // Kamera mengikuti posisi dan rotasi mobil
            if (!carModel) return;

            // Offset kamera di atas dan sedikit di belakang mobil
            const cameraOffset = new THREE.Vector3(0, 20, -10); // Y = atas, Z = belakang
            // Transform offset ke ruang dunia sesuai rotasi mobil
            const worldOffset = cameraOffset.applyMatrix4(new THREE.Matrix4().makeRotationY(carModel.rotation.y));
            camera.position.copy(carModel.position).add(worldOffset);

            // Kamera menghadap ke arah depan mobil
            const lookAtOffset = new THREE.Vector3(0, 10, 40); // Y = sedikit atas, Z = depan
            const worldLookAt = lookAtOffset.applyMatrix4(new THREE.Matrix4().makeRotationY(carModel.rotation.y));
            camera.lookAt(carModel.position.clone().add(worldLookAt));
        }

        async function loadCathedralModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Cathedral.glb');
                const cathedral = gltf.scene;
                // Tempatkan cathedral pada X: -1137, Z: -155
                cathedral.position.set(-1110, 0.1, -155);
                cathedral.scale.set(20, 20, 20); // Sesuaikan skala jika perlu
                cathedral.rotation.y = Math.PI; // Rotasi jika perlu

                cathedral.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(cathedral);

                // Tambahkan collision box untuk cathedral
                createCollisionBox(cathedral, 0, 10, 0, 1, 1, 1); // Perbesar collision jika perlu
            } catch (error) {
                console.error('Gagal memuat model cathedral:', error);
            }
        }

        async function loadSmallBuildingModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Small Building.glb');
                const smallBuilding = gltf.scene;
                // Tempatkan small building pada X: -911, Z: 215
                smallBuilding.position.set(-850, 0.1, 140);
                smallBuilding.scale.set(150, 150, 150); // Sesuaikan skala jika perlu
                smallBuilding.rotation.y = 0; // Rotasi jika perlu

                smallBuilding.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(smallBuilding);

                // Tambahkan collision box untuk small building
                createCollisionBox(smallBuilding, 0, 10, 0, 1, 1, 1); // Perbesar collision jika perlu
            } catch (error) {
                console.error('Gagal memuat model small building:', error);
            }
        }

        async function loadBakeryModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Bakery.glb');
                const familymart = gltf.scene;
                // Tempatkan Familymart pada X: -828, Z: -174
                familymart.position.set(-557, 0.1, 113);
                familymart.scale.set(9, 9, 9); // Sesuaikan skala jika perlu
                familymart.rotation.y = Math.PI; // Rotasi jika perlu

                familymart.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(familymart);

                // Tambahkan collision box untuk Familymart
                createCollisionBox(familymart, 0, 10, 0, 1, 1, 1); // Perbesar collision jika perlu
            } catch (error) {
                console.error('Gagal memuat model Familymart:', error);
            }
        }

        async function loadHungryJacksModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/hungryjacks.glb');
                const supermarket = gltf.scene;
                // Tempatkan supermarket pada X: -427, Z: 171
                supermarket.position.set(-680, 1, -245);
                supermarket.scale.set(8.5, 8.5, 8.5); // Sesuaikan skala jika perlu
                supermarket.rotation.y = 0; // Rotasi jika perlu

                supermarket.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(supermarket);

                // Tambahkan collision box untuk supermarket
                createCollisionBox(supermarket, 0, 10, 0, 1, 1, 1);
            } catch (error) {
                console.error('Gagal memuat model supermarket:', error);
            }
        }

        async function loadPoliceStationModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/police_station.glb');
                const policeStation = gltf.scene;
                // Posisikan police station di lokasi yang sesuai
                policeStation.position.set(300, 0.1, 210); // Sesuaikan koordinat sesuai kebutuhan
                policeStation.scale.set(3.1,3.1,3.1); // Sesuaikan skala sesuai kebutuhan
                policeStation.rotation.y = Math.PI; // Sesuaikan rotasi sesuai kebutuhan

                policeStation.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(policeStation);

                // Tambahkan collision box
                createCollisionBox(policeStation, 0, 10, 0, 0.7, 0.7, 0.7);
            } catch (error) {
                console.error('Gagal memuat model police station:', error);
            }
        }

        async function loadWarehouseModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/asia_building.glb');
                const warehouse = gltf.scene;
                
                // Posisikan warehouse di lokasi yang sesuai
                warehouse.position.set(-140, 0.1, 212);
                warehouse.scale.set(2.2, 2.2, 2.2);
                warehouse.rotation.y = Math.PI;

                warehouse.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(warehouse);

                // Mengecilkan collision box dengan mengubah parameter scaling
                createCollisionBox(warehouse, 0, 10, 0, 1, 1, 1); // Ubah nilai scaling menjadi lebih kecil
            } catch (error) {
                console.error('Gagal memuat model warehouse:', error);
            }
        }

        async function loadStopSign() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/stop_sign.glb');
                const stopsign = gltf.scene;
                
                // Posisikan stopsign di lokasi yang sesuai
                stopsign.position.set(-330.94, 40, 88.23);
                stopsign.scale.set(1, 2, 1);
                stopsign.rotation.y = Math.PI + 0.66;

                stopsign.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(stopsign);

                // Mengecilkan collision box dengan mengubah parameter scaling
                createCollisionBox(stopsign, 0, 10, 0, 1, 1, 1); // Ubah nilai scaling menjadi lebih kecil
            } catch (error) {
                console.error('Gagal memuat model stopsign:', error);
            }
        }

        // Tambahkan fungsi berikut di bawah loadStopSign()
async function loadTownHouseModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/Town House.glb');
        const townHouse = gltf.scene;
        // Tempatkan Town House pada X: 473, Z: -223
        townHouse.position.set(550, 0.1, -135);
        townHouse.scale.set(45, 45, 55); // Sesuaikan skala jika perlu
        townHouse.rotation.y = 0; // Rotasi jika perlu

        townHouse.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(townHouse);

        // Tambahkan collision box untuk Town House
        createCollisionBox(townHouse, 0, 10, 0, 1, 1, 1);
    } catch (error) {
        console.error('Gagal memuat model Town House:', error);
    }
}

async function loadBillboardModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/abandoned_billboard.glb');
        const billboard = gltf.scene;
        
        // Position the billboard appropriately
        billboard.position.set(1167.03, 0.1, -139.73); // Adjust coordinates as needed
        billboard.scale.set(50, 50, 50); // Adjust scale as needed
        billboard.rotation.y = Math.PI - 1.2; // Adjust rotation as needed

        billboard.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(billboard);

        // Add collision box - using smaller values since it's a thin structure
        createCollisionBox(billboard, 0, 5, 0, 0.3, 0.8, 0.1);
    } catch (error) {
        console.error('Failed to load billboard model:', error);
    }
}

async function loadTungTung() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/tung_tung_tung_sahur_for_horror_free_download.glb');
        const horrorAudio = gltf.scene;
        
        // Position the horror audio model appropriately
        horrorAudio.position.set(363.46, 0.1, -79.52); // Adjust coordinates as needed
        horrorAudio.scale.set(15, 15, 15); // Adjust scale as needed
        horrorAudio.rotation.y = (Math.PI) + 1.2; // Adjust rotation as needed

        horrorAudio.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(horrorAudio);

        // Add collision box with small footprint
        createCollisionBox(horrorAudio, 0, 5, 0, 0.2, 0.8, 0.2);
    } catch (error) {
        console.error('Failed to load horror audio model:', error);
    }
}

async function loadFarmHouseModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/Farm house.glb');
        const farmHouse = gltf.scene;
        
        // Position the farm house appropriately
        farmHouse.position.set(800, 0.1, 200); // Adjust coordinates as needed
        farmHouse.scale.set(12, 12, 12); // Adjust scale as needed
        farmHouse.rotation.y = Math.PI; // Adjust rotation as needed

        farmHouse.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(farmHouse);

        // Add collision box with appropriate size
        createCollisionBox(farmHouse, 0, 10, 0, 0.8, 1, 0.8);
    } catch (error) {
        console.error('Failed to load farm house model:', error);
    }
}

async function loadWelcomeBoardModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/malaysia_road_sign.glb');
        const welcomeBoard = gltf.scene;
        
        // Position the welcome board
        welcomeBoard.position.set(-423.31, 0.1, -245.07); // Adjust coordinates as needed
        welcomeBoard.scale.set(75, 75, 155); // Adjust scale as needed
        welcomeBoard.rotation.y = 0; // Adjust rotation as needed

        welcomeBoard.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(welcomeBoard);

        // Add collision box - using thinner values since it's a gate structure
        createCollisionBox(welcomeBoard, 0, 10, 0, 0, 0, 0);
    } catch (error) {
        console.error('Failed to load welcome board model:', error);
    }
}

async function loadOldBuildingModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/old_building__lowpoly.glb');
        const oldBuilding = gltf.scene;
        
        // Position the old building
        oldBuilding.position.set(550, 0.1, 200); // Adjust coordinates as needed
        oldBuilding.scale.set(20, 20, 20); // Adjust scale as needed
        oldBuilding.rotation.y = Math.PI / 2; // Adjust rotation as needed

        oldBuilding.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(oldBuilding);

        // Add collision box with appropriate size
        createCollisionBox(oldBuilding, 0, 10, 0, 0.8, 1, 0.8);
    } catch (error) {
        console.error('Failed to load old building model:', error);
    }
}

async function loadGhostModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/low_poly_ghost_character.glb');
        const ghost = gltf.scene;
        // Sesuaikan posisi, skala dan rotasi
        ghost.position.set(-775, 10, -100);
        ghost.scale.set(1, 1, 1);
        ghost.rotation.y = Math.PI / 4;

        ghost.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 0.8;
                    child.material.emissive = new THREE.Color(0x444444);
                    child.material.emissiveIntensity = 0.2;
                }
            }
        });

        scene.add(ghost);
        window.ghostModel = ghost;
        createCollisionBox(ghost, 0, 5, 0, 0.8, 1, 0.8);
        console.log('Ghost model loaded');
    } catch (error) {
        console.error('Failed to load ghost model:', error);
    }
}

// Add this function to load the Chaos Emerald
async function loadChaosEmeraldModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/chaos_emerald_-_sonic_the_hedgehog.glb');
        
        // Create 10 emeralds at different positions
        const emeraldPositions = [
            { x: 0, y: 5, z: 0 },
            { x: -715.01, y: 5, z: -389.81 },
            { x: -483.04, y: 5, z: 194.15 },
            { x: -142.41, y: 5, z: -366.10 },
            { x: 360, y: 5, z: -182.67 },
            { x: 300, y: 5, z: 0 },
            { x: -300, y: 5, z: 0 } // didalam rumah sakit
            ,
            { x: 500, y: 5, z: 0 },
            { x: 0, y: 5, z: 0 },
            { x: 242.86, y: 13, z: 332.78 }
        ];

        for (let i = 0; i < TOTAL_EMERALDS; i++) {
            const emerald = gltf.scene.clone();
            
            // Position the emerald
            emerald.position.set(
                emeraldPositions[i].x,
                emeraldPositions[i].y,
                emeraldPositions[i].z
            );
            emerald.scale.set(5, 5, 5);
            emerald.rotation.y = 0;

            // Make it emit light
            const emeraldLight = new THREE.PointLight(0x00ff00, 2, 50);
            emeraldLight.position.set(0, 0, 0);
            emerald.add(emeraldLight);

            emerald.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.shadowSide = THREE.FrontSide;
                        child.material.emissive = new THREE.Color(0x00ff00);
                        child.material.emissiveIntensity = 0.5;
                    }
                }
            });

            scene.add(emerald);
            chaosEmeralds.push(emerald);

            // Tambahkan collision box untuk emerald
            const emeraldBox = createCollisionBox(emerald, 0, 5, 0, 0.3, 0.3, 0.3);
            emeraldCollisionBoxes.push(emeraldBox);
        }

    } catch (error) {
        console.error('Failed to load Chaos Emerald models:', error);
    }
}

function updateEmeraldAnimation(emerald, index) {
    const time = Date.now() * 0.001; // Convert to seconds
    
    // Rotasi emerald
    emerald.rotation.y += 0.03;
    emerald.rotation.x += 0.01;
    
    // Floating effect dengan variasi per emerald
    const baseY = 8;
    const floatHeight = 3;
    const floatSpeed = 2 + (index * 0.3);
    emerald.position.y = baseY + Math.sin(time * floatSpeed + index) * floatHeight;
    
    // Pulsing light effect
    emerald.traverse(child => {
        if (child.isMesh && child.material && child.material.emissive) {
            const pulse = 0.2 + Math.sin(time * 3 + index) * 0.1;
            child.material.emissiveIntensity = pulse;
        }
    });
}

function updateEmeraldUI() {
    // Update counter di kanan atas
    const emeraldCounter = document.getElementById('emerald-counter');
    if (emeraldCounter) {
        emeraldCounter.innerHTML = `💎 ${collectedEmeralds} / ${TOTAL_EMERALDS}`;
        
        // Animasi bounce pada counter
        emeraldCounter.style.transform = 'scale(1.2)';
        setTimeout(() => {
            emeraldCounter.style.transform = 'scale(1)';
        }, 200);
    }

    // Update pesan emerald
    const emeraldMsg = document.getElementById('emerald-message');
    if (emeraldMsg) {
        const remaining = TOTAL_EMERALDS - collectedEmeralds;
        if (remaining > 0) {
            emeraldMsg.innerText = `${remaining} Chaos Emerald Remaining`;
            emeraldMsg.style.color = "#ff0000";
            emeraldMsg.style.fontSize = "18px";
        }
    }
}

function collectEmerald(emerald, index) {
    console.log(`Collecting emerald ${index}!`);
    
    // Play sound effect
    if (emeraldCollectSound) {
        emeraldCollectSound.currentTime = 0;
        emeraldCollectSound.volume = 0.6;
        emeraldCollectSound.play().catch(error => {
            console.log("Emerald collect sound failed:", error);
        });
    }
    
    // Simpan posisi untuk efek visual
    const emeraldPosition = emerald.position.clone();
    
    // Remove emerald dari scene
    scene.remove(emerald);
    chaosEmeralds[index] = null;
    collectedEmeralds++;
    
    // **PERBAIKAN: TAMPILKAN GAMBAR HORROR UNTUK SETIAP EMERALD**
    if (collectedEmeralds === 1 && !firstEmeraldCollected) {
        firstEmeraldCollected = true;
        console.log("First emerald collected - triggering horror image!");
        setTimeout(() => {
            showRandomHorrorImage();
            // if it's already night, spawn the ghost now
            if (isNight && !ghostSpawned) {
                console.log("Spawning ghost - first emerald + night mode!");
                loadGhostModel();
                ghostSpawned = true;
            }
        }, 1000); // Delay 1 detik setelah mengambil emerald
    } else if (collectedEmeralds > 1) {
        // TAMBAHAN: Tampilkan gambar horror untuk emerald ke-2 dan seterusnya
        console.log(`Emerald ${collectedEmeralds} collected - triggering horror image!`);
        
        // Peluang 70% untuk menampilkan gambar horror (agar tidak terlalu sering)
        if (Math.random() < 0.7) {
            setTimeout(() => {
                showRandomHorrorImage();
            }, 500 + Math.random() * 1500); // Delay acak antara 0.5-2 detik
        }
    }
    
    // Update UI
    updateEmeraldUI();
    
    // Efek visual
    createCollectionEffects(emeraldPosition);
    
    // Cek apakah game selesai
    if (collectedEmeralds >= TOTAL_EMERALDS) {
        onGameComplete();
    }
}

// Update the checkEmeraldCollection function
function checkEmeraldCollection() {
    if (collectedEmeralds >= TOTAL_EMERALDS) {
        return; // Game sudah selesai
    }
    
    const playerPosition = camera.position.clone();
    const collectionRadius = 25; // Radius yang lebih besar untuk kemudahan
    
    // Update animasi emerald dan cek collection
    for ( let i = 0; i < chaosEmeralds.length; i++) {
        const emerald = chaosEmeralds[i];
        
        if (emerald && emerald.parent) { // Pastikan emerald masih ada di scene
            // Animasi emerald
            updateEmeraldAnimation(emerald, i);
            
            // Cek jarak untuk collection
            const emeraldPos = emerald.position.clone();
            const distance = playerPosition.distanceTo(emeraldPos);
            
            if (distance < collectionRadius) {
                collectEmerald(emerald, i);
                break; // Kumpulkan satu emerald per frame
            }
        }
    }
}

function createCollectionEffects(position) {
    // Tidak perlu flashLight effect

    // Sparkle particles
    const particleCount = 3; // Hanya 3 partikel
    const particles = [];

    for (let i = 0; i < particleCount; i++) {
        const particle = new THREE.Mesh(
            new THREE.SphereGeometry(0.7, 12, 12), // Lebih tebal (besar dan lebih halus)
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color().setHSL(0.3 + Math.random() * 0.1, 1, 0.7),
                emissive: 0x00ff00,
                transparent: true,
                opacity: 1
            })
        );
        particle.position.copy(position);
        particle.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            Math.random() * 15 + 5,
            (Math.random() - 0.5) * 20
        );
        particle.userData.life = 1.0;
        scene.add(particle);
        particles.push(particle);
    }

    // Animate particles (pakai loop mundur)
    function animateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const particle = particles[i];
            if (particle.userData.life <= 0) {
                scene.remove(particle);
                particles.splice(i, 1);
                continue;
            }
            // Update position
            particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.02));
            particle.userData.velocity.y -= 0.5; // Gravity
            // Update life and opacity
            particle.userData.life -= 0.02;
            particle.material.opacity = particle.userData.life;
            particle.scale.setScalar(particle.userData.life);
        }
        if (particles.length > 0) {
            requestAnimationFrame(animateParticles);
        }
    }
    animateParticles();
}

// Tambahkan setelah fungsi createCollectionEffects dan sebelum checkCreepySoundTrigger
function onGameComplete() {
    console.log("Game Complete! All emeralds collected!");
    
    // Stop creepy sound immediately
    if (isCreepySingingPlaying && creepySinging) {
        creepySinging.pause();
        creepySinging.currentTime = 0;
        isCreepySingingPlaying = false;
        console.log("Stopped creepy singing - Game won!");
    }
    
    // Force change to day mode
    isNight = false;
    
    // Update lighting to day
    if (ambientLight) {
        ambientLight.intensity = 0.5;
    }
    if (directionalLight) {
        directionalLight.intensity = 0.8;
    }
    
    // Change sky color to day
    scene.background = new THREE.Color(0x87CEEB);
    
    // Turn off flashlight
    if (flashlight) {
        flashlight.intensity = 0;
    }
    
    // Reset creepy trigger
    creepyTriggered = false;
    
    // Show victory message
    const emeraldMsg = document.getElementById('emerald-message');
    if (emeraldMsg) {
        emeraldMsg.innerText = "🏆 MENANG! Semua Chaos Emerald terkumpul! 🏆";
        emeraldMsg.style.color = "#FFD700";
        emeraldMsg.style.fontSize = "24px";
    }
    
    console.log("Victory! Game completed and switched to day mode!");
}

// Add this function after the existing functions
function checkCreepySoundTrigger() {
    if (isNight) {
        // Perbaiki area trigger agar lebih luas dan mudah diaktifkan
        const triggerArea = {
            minX: -1200, // diperluas ke kiri
            maxX: -300,  // diperluas ke kanan
            minZ: -300,  // diperluas ke depan
            maxZ: 300    // diperluas ke belakang
        };

        // Cek apakah player di area trigger
        const isInTriggerArea = (
            camera.position.x >= triggerArea.minX && 
            camera.position.x <= triggerArea.maxX &&
            camera.position.z >= triggerArea.minZ && 
            camera.position.z <= triggerArea.maxZ
        );

        // Jika masuk area dan mode malam
        if (isInTriggerArea) {
            // Load emeralds hanya sekali
            if (!emeraldsLoaded) {
                console.log("Loading Chaos Emeralds...");
                loadChaosEmeraldModel();
                emeraldsLoaded = true;
            }

            // Play creepy sound jika belum dimainkan
            if (!isCreepySingingPlaying && creepySinging) {
                console.log("Playing creepy singing...");
                creepySinging.loop = true;
                creepySinging.volume = 0.3;
                creepySinging.play().then(() => {
                    isCreepySingingPlaying = true;
                    console.log("Creepy singing started successfully");
                }).catch(error => {
                    console.log("Audio play failed:", error);
                });
            }
            
            creepyTriggered = true;
        }
    } else {
        // Reset saat mode siang
        if (isCreepySingingPlaying && creepySinging) {
            creepySinging.pause();
            creepySinging.currentTime = 0;
            isCreepySingingPlaying = false;
            console.log("Stopped creepy singing");
        }
        
        // Reset flags
        creepyTriggered = false;
        
        // Hapus emerald saat siang
        if (emeraldsLoaded) {
            console.log("Removing emeralds for day mode");
            chaosEmeralds.forEach(e => { if (e) scene.remove(e); });
            emeraldCollisionBoxes.forEach(b => { if (b) scene.remove(b); });
            chaosEmeralds.length = 0;
            emeraldCollisionBoxes.length = 0;
            emeraldsLoaded = false;
            collectedEmeralds = 0;
            updateEmeraldUI();
        }
    }
}

// Missing collision functions
function moveWithCollision(moveVector) {
    const currentPosition = camera.position.clone();
    const newPosition = currentPosition.clone().add(moveVector);
    
    // Simple collision detection
    let collision = false;
    for (let i = 0; i < collisionObjects.length; i++) {
        const obj = collisionObjects[i];
        const distance = newPosition.distanceTo(obj.position);
        if (distance < playerRadius + 10) // Add some buffer
            collision = true;
            break;
    }
    
    if (!collision) {
        camera.position.copy(newPosition);
    }
}

function checkCarCollisions(plannedPosition) {
    // SKIP collision check jika tidak ada carCollisionBox
    if (!carCollisionBox) {
        return false; // Tidak ada collision
    }
    
    for (let i = 0; i < collisionObjects.length; i++) {
        const obj = collisionObjects[i];
        // Skip jika objek adalah collision box mobil sendiri
        if (obj === carCollisionBox) continue;
        
        const distance = plannedPosition.distanceTo(obj.position);
        if (distance < 30) { // Car collision radius
            return true; // Collision detected
        }
    }
    return false; // No collision
}

// Add flickering to streetlights for extra horror atmosphere
function flickerStreetLights() {
    if (!isNight || !window.streetLampLights) return;
    
    window.streetLampLights.forEach(light => {
        if (Math.random() < 0.08) { // 8% chance each frame
            const originalIntensity = 1.5;
            light.intensity = originalIntensity * (0.2 + Math.random() * 0.6);
            
            setTimeout(() => {
                light.intensity = originalIntensity;
            }, 100 + Math.random() * 300);
        }
    });
}

// Missing horror image functions
function loadHorrorImages() {
    // Initialize horror images array
    horrorImages = [
        '/2dmodel/photo0.jpg',
        '/2dmodel/photo1.jpg',
        '/2dmodel/photo2.jpg',
        '/2dmodel/photo3.jpg'
    ];
    horrorImagesLoaded = true;
    console.log('Horror images loaded');
}

function showRandomHorrorImage() {
    if (!horrorImagesLoaded || horrorImages.length === 0) {
        console.log("Horror images not loaded or empty");
        return;
    }
    
    const randomIndex = Math.floor(Math.random() * horrorImages.length);
    const imageUrl = horrorImages[randomIndex];
    
    console.log(`Showing horror image: ${imageUrl}`);
    
    // Create horror image overlay
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100vw';
    overlay.style.height = '100vh';
    overlay.style.backgroundColor = 'rgba(0,0,0,0.95)';
    overlay.style.zIndex = '9999';
    overlay.style.display = 'flex';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.cursor = 'pointer'; // Tambahkan cursor pointer
    
    const img = document.createElement('img');
    img.src = imageUrl;
    img.style.maxWidth = '90%';
    img.style.maxHeight = '90%';
    img.style.objectFit = 'contain';
    img.style.border = '3px solid #ff0000';
    img.style.boxShadow = '0 0 30px rgba(255,0,0,0.5)';
    
    // Tambahkan efek fade in
    overlay.style.opacity = '0';
    overlay.style.transition = 'opacity 0.3s ease-in-out';
    
    overlay.appendChild(img);
    document.body.appendChild(overlay);
    
    // Fade in
    setTimeout(() => {
        overlay.style.opacity = '1';
    }, 10);
    
    // Click to close atau auto close setelah 3 detik
    const closeImage = () => {
        overlay.style.opacity = '0';
        setTimeout(() => {
            if (overlay.parentNode) {
                document.body.removeChild(overlay);
            }
        }, 300);
    };
    
    overlay.addEventListener('click', closeImage);
    
    // Auto close setelah 3 detik
    setTimeout(closeImage, 3000);
    
    console.log('Horror image shown successfully');
}

// Call createSimpleStreetlamps in init function
// Add this to your init() function after createGround():
createSimpleStreetlamps();
    </script>
</body>
</html>