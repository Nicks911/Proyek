<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini City - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
    </script>
</head>
<body>
    <div id="info">WASD untuk bergerak, Mouse untuk melihat sekitar</div>
    
    <script type="module">
        // Import Three.js dari CDN dengan path yang benar
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

        // Variabel global
        let scene, camera, renderer;
        let ground;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let velocity = new THREE.Vector3();
        let prevTime = performance.now();
        const speed = 100.0;

        // Kontrol kamera
        const cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
        
        // Inisialisasi scene
        function init() {
            // Membuat scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Membuat kamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.set(0, 10, 50);
            camera.rotation.order = 'YXZ';
            
            // Menambahkan cahaya
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Membuat tanah
            createGround();
            
            // Tambahkan road 4 arah
            create4WayRoad();
            
            // Load model hospital
            loadHospitalModel();
            
            // Tambahkan streetlamp sepanjang ujung map
            createStreetlamps();
            
            // Setup renderer, event listener, dan animasi
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            
            animate();
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2E8B57,
                side: THREE.DoubleSide
            });
            
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const gridHelper = new THREE.GridHelper(1000, 50);
            scene.add(gridHelper);
        }

        async function loadHospitalModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('low_poly_hospital.glb');
                
                const hospital = gltf.scene;
                // Lower the hospital so it sits on the ground (y set to 0)
                hospital.position.set(-216, 0.1, -229);
                hospital.scale.set(12, 12, 12);
                // Set rotasi supaya hospital sejajar dengan jalan (misal, jalan mendatar sepanjang sumbu X)
                hospital.rotation.y = 0; 
                
                hospital.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(hospital);
            } catch (error) {
                console.error('Gagal memuat model rumah sakit:', error);
                createSimpleHospital();
            }
        }

        function createSimpleHospital() {
            // Fallback: create a simple red box as a hospital model substitute
            const geometry = new THREE.BoxGeometry(1000, 10, 10);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const simpleHospital = new THREE.Mesh(geometry, material);
            simpleHospital.position.set(50, 5, 50);
            simpleHospital.castShadow = true;
            simpleHospital.receiveShadow = true;
            scene.add(simpleHospital);
        }

        function createRoad() {
            // Definisikan dimensi jalan
            const roadWidth = 20; 
            const roadLength = 500; // panjang jalan dibuat memanjang
            const roadGeometry = new THREE.PlaneGeometry(roadLength, roadWidth);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2; // putar sehingga datar

            // Set posisi jalan di depan rumah sakit: (x: 228, y: 10, z: 104)
            road.position.set(228, 10, 104); 
            road.receiveShadow = true;
            scene.add(road);
        }

        function create4WayRoad() {
            const roadColor = 0x333333;
            const roadMaterial = new THREE.MeshStandardMaterial({ color: roadColor });
            const groundSize = 5000; // same size as the ground
            const roadWidth = 100; // road width

            // Horizontal road (along X axis)
            const horizontalGeometry = new THREE.PlaneGeometry(groundSize, roadWidth);
            const horizontalRoad = new THREE.Mesh(horizontalGeometry, roadMaterial);
            horizontalRoad.rotation.x = -Math.PI / 2;
            // By default, the center of the plane is at (0, 0, 0) so no additional offset is needed:
            horizontalRoad.position.set(0, 0.11, 0);
            
            // Vertical road (along Z axis)
            const verticalGeometry = new THREE.PlaneGeometry(roadWidth, groundSize);
            const verticalRoad = new THREE.Mesh(verticalGeometry, roadMaterial);
            verticalRoad.rotation.x = -Math.PI / 2;
            verticalRoad.position.set(0, 0.11, 0);
            
            // Create a group to hold both roads with its origin at (0, 0, 0)
            const roadGroup = new THREE.Group();
            roadGroup.add(horizontalRoad);
            roadGroup.add(verticalRoad);
            roadGroup.position.set(0, 0, 0); // memastikan titik tengah road ada di 0,0

            scene.add(roadGroup);
        }

        function createBuildingWithLand(buildingModel, landWidth, landHeight, landColor, position) {
            // Buat "land" menggunakan plane geometry
            const landGeometry = new THREE.PlaneGeometry(landWidth, landHeight);
            const landMaterial = new THREE.MeshStandardMaterial({ color: landColor });
            const landMesh = new THREE.Mesh(landGeometry, landMaterial);
            landMesh.rotation.x = -Math.PI / 2;
            landMesh.receiveShadow = true;
            
            // Buat grup untuk menggabungkan tanah dan bangunan
            const buildingGroup = new THREE.Group();
            
            // Atur posisi tanah (misal, pusat grup)
            landMesh.position.set(0, 0, 0);
            buildingGroup.add(landMesh);
            
            // Atur posisi building pada grup. Jika building model pivot sudah di tengah,
            // kamu bisa letakkan tepat di atas tanah.
            buildingModel.position.set(0, 0, 0);
            buildingGroup.add(buildingModel);
            
            // Lokal posisi grup sesuai parameter posisi (misal, tempat bangunan di scene)
            buildingGroup.position.copy(position);
            
            scene.add(buildingGroup);
            
            return buildingGroup;
        }

        function createStreetlamps() {
            const streetlampPath = 'streetlight_-_low_poly__stylized.glb';
            const spacing = 250; // Jarak antar streetlamp
            const halfSize = 2500; // Karena ground 5000x5000, setengahnya 2500
            const loader = new GLTFLoader();

            loader.load(
                streetlampPath,
                gltf => {
                    const baseLamp = gltf.scene;
                    // Anda bisa sesuaikan scale atau rotasi jika diperlukan, misalnya:
                    // baseLamp.scale.set(1, 1, 1);

                    // Tempatkan lampu di sisi atas dan bawah (sumbu X)
                    for (let x = -halfSize; x <= halfSize; x += spacing) {
                        let lampTop = baseLamp.clone();
                        lampTop.position.set(x, 0, halfSize);
                        scene.add(lampTop);

                        let lampBottom = baseLamp.clone();
                        lampBottom.position.set(x, 0, -halfSize);
                        scene.add(lampBottom);
                    }

                    // Tempatkan lampu di sisi kiri dan kanan (sumbu Z)
                    // Hindari duplikasi di sudut dengan mulai dari -halfSize+spacing hingga halfSize-spacing
                    for (let z = -halfSize + spacing; z <= halfSize - spacing; z += spacing) {
                        let lampLeft = baseLamp.clone();
                        lampLeft.position.set(-halfSize, 0, z);
                        scene.add(lampLeft);

                        let lampRight = baseLamp.clone();
                        lampRight.position.set(halfSize, 0, z);
                        scene.add(lampRight);
                    }
                },
                undefined,
                error => {
                    console.error('Error loading streetlamp model:', error);
                }
            );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        function onMouseMove(event) {
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            const sensitivity = 0.002;
            // Update yaw (rotation around y)
            cameraRotation.y -= movementX * sensitivity;
            // Update pitch (rotation around x) and clamp between -90° and 90°
            cameraRotation.x -= movementY * sensitivity;
            cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
            
            camera.rotation.x = cameraRotation.x;
            camera.rotation.y = cameraRotation.y;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // Determine movement direction with corrected W/S behavior:
            // W: forward, S: backward
            let moveDirection = new THREE.Vector3();
            if (moveForward) moveDirection.z += 1; // Forward
            if (moveBackward) moveDirection.z -= 1; // Backward
            if (moveLeft) moveDirection.x -= 1;
            if (moveRight) moveDirection.x += 1;
            moveDirection.normalize();

            // Get camera's forward vector (ignoring y component)
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            // Compute camera's right vector
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            // Calculate movement vector
            const move = new THREE.Vector3();
            move.addScaledVector(forward, moveDirection.z * speed * delta);
            move.addScaledVector(right, moveDirection.x * speed * delta);

            // Update camera position
            camera.position.add(move);
            prevTime = time;

            renderer.render(scene, camera);

            // Update info display with camera's position
            const infoEl = document.getElementById('info');
            infoEl.innerHTML = `WASD untuk bergerak, Mouse untuk melihat sekitar<br>
                Kamera Posisi: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`;
        }

        // Request pointer lock on click:
        document.body.addEventListener('click', () => {
            document.body.requestPointerLock();
        });

        init();
    </script>
</body>
</html>