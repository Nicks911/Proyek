<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open World - Three.js and WebGL2</title>
    <link rel="stylesheet" href="../static/css/style.css">
</head>
<body>
    <div id="container"></div>
    <div id="info">
        WASD - Move | Shift - Run | Space - Jump<br>
        Mouse - Look around<br>
        Click to lock/unlock mouse
    </div>
    <div id="loading">
        Loading the world...<br>
        Please wait
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { Water } from 'three/addons/objects/Water.js';

        // Main class to handle the open world
        class OpenWorld {
            constructor() {
                // Scene setup
                this.container = document.getElementById('container');
                this.loadingElement = document.getElementById('loading');
                
                // Create renderer with WebGL2
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance",
                    alpha: false
                });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 0.5;
                
                // Force WebGL2
                this.renderer.getContext().getExtension('EXT_color_buffer_float');
                
                this.container.appendChild(this.renderer.domElement);
                
                // Initialize Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x88ccff);
                this.scene.fog = new THREE.FogExp2(0x88ccff, 0.002);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 1.6, 5);
                
                // Controls
                this.initControls();
                
                // Set up clock for animations
                this.clock = new THREE.Clock();
                
                // Player movement state
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.playerOnFloor = true;
                
                // Input tracking
                this.keyStates = {};
                this.pointerLocked = false;
                
                // World objects
                this.models = [];
                
                // Bind methods
                this.animate = this.animate.bind(this);
                this.onWindowResize = this.onWindowResize.bind(this);
                
                // Event listeners
                window.addEventListener('resize', this.onWindowResize);
                document.addEventListener('keydown', (event) => { this.keyStates[event.code] = true; });
                document.addEventListener('keyup', (event) => { this.keyStates[event.code] = false; });
                document.addEventListener('click', () => this.lockPointer());
                
                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                // Initialize world
                this.initWorld();
                
                // Start animation loop
                this.animate();
            }
            
            // Initialize world geometry and lighting
            async initWorld() {
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
                directionalLight.position.set(1, 50, 1);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.camera.far = 100;
                this.scene.add(directionalLight);
                
                // Create world terrain
                this.createTerrain();
                
                // Create sky and day/night cycle
                this.createSky();
                
                // Create water
                this.createWater();
                
                // Load GLB model
                await this.loadModels();
                
                // Place some trees and rocks
                this.createEnvironment();
                
                // Hide loading screen
                this.loadingElement.classList.add('hidden');
            }
            
            // Create terrain
            createTerrain() {
                // Create ground plane
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
                groundGeometry.rotateX(-Math.PI / 2);
                
                // Add some terrain variation
                const vertices = groundGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    // Skip the center area to keep it flat for player
                    const x = vertices[i];
                    const z = vertices[i + 2];
                    const distance = Math.sqrt(x * x + z * z);
                    
                    if (distance > 10) {
                        vertices[i + 1] = this.noise(vertices[i] / 20, vertices[i + 2] / 20) * 2;
                        
                        // Add mountains in the distance
                        if (distance > 50) {
                            const mountainFactor = Math.pow((distance - 50) / 50, 2) * 15;
                            vertices[i + 1] += this.noise(vertices[i] / 100, vertices[i + 2] / 100) * mountainFactor;
                        }
                    }
                }
                
                // Update normals after modifying vertices
                groundGeometry.computeVertexNormals();
                
                // Create ground material
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x567d46,
                    metalness: 0,
                    roughness: 0.9
                });
                
                // Create ground mesh
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                ground.name = 'ground';
                this.scene.add(ground);
                
                // Create collision box for the ground
                this.groundY = 0;
            }
            
            // Simple noise function for terrain generation
            noise(x, z) {
                return Math.sin(x * 5) * Math.cos(z * 2.5) + 
                       Math.sin(x * 1.5) * Math.cos(z * 6.5) * 0.5 + 
                       Math.sin(x * 0.12) * Math.cos(z * 0.15) * 5;
            }
            
            // Create sky with sun
            createSky() {
                // Create sky
                this.sky = new Sky();
                this.sky.scale.setScalar(450000);
                this.scene.add(this.sky);
                
                // Configure sky
                const skyUniforms = this.sky.material.uniforms;
                skyUniforms['turbidity'].value = 10;
                skyUniforms['rayleigh'].value = 2;
                skyUniforms['mieCoefficient'].value = 0.005;
                skyUniforms['mieDirectionalG'].value = 0.8;
                
                // Sun position parameters
                this.parameters = {
                    elevation: 30,
                    azimuth: 180
                };
                
                const sun = new THREE.Vector3();
                this.updateSun = () => {
                    const phi = THREE.MathUtils.degToRad(90 - this.parameters.elevation);
                    const theta = THREE.MathUtils.degToRad(this.parameters.azimuth);
                    
                    sun.setFromSphericalCoords(1, phi, theta);
                    this.sky.material.uniforms['sunPosition'].value.copy(sun);
                    if (this.water) {
                        this.water.material.uniforms['sunDirection'].value.copy(sun).normalize();
                    }
                };
                
                this.updateSun();
            }
            
            // Create water plane
            createWater() {
                // Create water geometry
                const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
                
                // Create water
                this.water = new Water(
                    waterGeometry,
                    {
                        textureWidth: 512,
                        textureHeight: 512,
                        waterNormals: new THREE.TextureLoader().load('https://unpkg.com/three@0.159.0/examples/textures/waternormals.jpg', (texture) => {
                            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        }),
                        sunDirection: new THREE.Vector3(),
                        sunColor: 0xffffff,
                        waterColor: 0x001e0f,
                        distortionScale: 3.7,
                        fog: this.scene.fog !== undefined
                    }
                );
                
                // Position the water
                this.water.rotation.x = -Math.PI / 2;
                this.water.position.y = -2;
                this.scene.add(this.water);
            }
            
            // Load GLB models
            async loadModels() {
                const loader = new GLTFLoader();
                
                try {
                    // Since we don't have real GLB models here, we'll create placeholders
                    // In a real implementation, you would replace this with actual model loading
                    
                    // Create a simple tree model using basic geometries
                    this.treeModel = new THREE.Group();
                    
                    // Tree trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.castShadow = true;
                    trunk.position.y = 1;
                    this.treeModel.add(trunk);
                    
                    // Tree foliage
                    const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
                    const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5e3e, roughness: 0.8 });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.castShadow = true;
                    foliage.position.y = 3;
                    this.treeModel.add(foliage);
                    
                    // Create a rock model
                    this.rockModel = new THREE.Group();
                    const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.castShadow = true;
                    rock.scale.set(1, 0.5, 0.8);
                    rock.rotation.set(0.2, 0.4, 0.1);
                    this.rockModel.add(rock);
                    
                    // Create a house model
                    this.houseModel = new THREE.Group();
                    
                    // House base
                    const baseGeometry = new THREE.BoxGeometry(3, 2.5, 4);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xd9bb97, roughness: 0.8 });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.castShadow = true;
                    base.position.y = 1.25;
                    this.houseModel.add(base);
                    
                    // House roof
                    const roofGeometry = new THREE.ConeGeometry(3, 2, 4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8b3e2f, roughness: 0.7 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.rotation.y = Math.PI / 4;
                    roof.position.y = 3.5;
                    this.houseModel.add(roof);
                    
                    // House door
                    const doorGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.1);
                    const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x5c2e0c, roughness: 0.8 });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 0.75, 2.01);
                    this.houseModel.add(door);
                    
                    // House windows
                    const windowGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.1);
                    const windowMaterial = new THREE.MeshStandardMaterial({ color: 0xadd8e6, roughness: 0.2 });
                    
                    const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window1.position.set(-1, 1.5, 2.01);
                    this.houseModel.add(window1);
                    
                    const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window2.position.set(1, 1.5, 2.01);
                    this.houseModel.add(window2);
                    
                    console.log("Models created successfully");
                } catch (error) {
                    console.error("Error creating models:", error);
                }
            }
            
            // Create environment by placing objects around the scene
            createEnvironment() {
                // Place trees
                for (let i = 0; i < 100; i++) {
                    if (!this.treeModel) continue;
                    
                    const x = (Math.random() - 0.5) * 200;
                    const z = (Math.random() - 0.5) * 200;
                    
                    // Don't place trees in the starting area
                    const distanceFromCenter = Math.sqrt(x * x + z * z);
                    if (distanceFromCenter < 15) continue;
                    
                    const tree = this.treeModel.clone();
                    
                    // Scale variation
                    const scale = 0.8 + Math.random() * 0.7;
                    tree.scale.set(scale, scale, scale);
                    
                    // Rotation variation
                    tree.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Position
                    tree.position.set(x, 0, z);
                    
                    // Add to scene
                    this.scene.add(tree);
                }
                
                // Place rocks
                for (let i = 0; i < 30; i++) {
                    if (!this.rockModel) continue;
                    
                    const x = (Math.random() - 0.5) * 150;
                    const z = (Math.random() - 0.5) * 150;
                    
                    // Don't place rocks in the starting area
                    const distanceFromCenter = Math.sqrt(x * x + z * z);
                    if (distanceFromCenter < 10) continue;
                    
                    const rock = this.rockModel.clone();
                    
                    // Scale variation
                    const scale = 0.5 + Math.random() * 1.5;
                    rock.scale.set(scale, scale * 0.8, scale);
                    
                    // Rotation variation
                    rock.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Position
                    rock.position.set(x, 0, z);
                    
                    // Add to scene
                    this.scene.add(rock);
                }
                
                // Place houses
                if (this.houseModel) {
                    const housePositions = [
                        { x: 20, z: 15, rotation: Math.PI * 0.5 },
                        { x: 25, z: 20, rotation: Math.PI * 0.75 },
                        { x: -30, z: -15, rotation: Math.PI * 1.5 }
                    ];
                    
                    housePositions.forEach(pos => {
                        const house = this.houseModel.clone();
                        house.position.set(pos.x, 0, pos.z);
                        house.rotation.y = pos.rotation;
                        this.scene.add(house);
                    });
                }
            }
            
            // Initialize player controls
            initControls() {
                // Set up pointer lock controls for first-person view
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.maxPolarAngle = Math.PI / 2;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 20;
                this.controls.enabled = false; // Start with controls disabled
                
                // Set up player movement
                this.playerHeight = 1.6;
                this.playerSpeed = 5.0;
                this.jumpVelocity = 5.0;
                this.gravity = 30.0;
            }
            
            // Lock/unlock pointer for camera control
            lockPointer() {
                if (!this.pointerLocked) {
                    this.renderer.domElement.requestPointerLock();
                }
            }
            
            // Update player position and camera
            updatePlayer(deltaTime) {
                // Only move if pointer is locked
                if (!this.pointerLocked) return;
                
                // Calculate movement direction based on camera orientation
                this.direction.z = Number(this.keyStates['KeyS']) - Number(this.keyStates['KeyW']);
                this.direction.x = Number(this.keyStates['KeyD']) - Number(this.keyStates['KeyA']);
                this.direction.normalize();
                
                // Check for jump
                if (this.keyStates['Space'] && this.playerOnFloor) {
                    this.velocity.y = this.jumpVelocity;
                    this.playerOnFloor = false;
                }
                
                // Apply gravity
                if (!this.playerOnFloor) {
                    this.velocity.y -= this.gravity * deltaTime;
                }
                
                // Move camera
                const speedMultiplier = this.keyStates['ShiftLeft'] ? 2.0 : 1.0;
                const actualSpeed = this.playerSpeed * speedMultiplier;
                
                // Forward/backward movement
                this.camera.position.z += this.direction.z * actualSpeed * deltaTime;
                
                // Left/right movement
                this.camera.position.x += this.direction.x * actualSpeed * deltaTime;
                
                // Apply vertical velocity
                this.camera.position.y += this.velocity.y * deltaTime;
                
                // Simple ground collision
                if (this.camera.position.y < this.playerHeight) {
                    this.camera.position.y = this.playerHeight;
                    this.velocity.y = 0;
                    this.playerOnFloor = true;
                }
                
                // Keep camera at constant height
                this.controls.target.copy(this.camera.position);
                this.controls.target.y = this.camera.position.y - 0.5;
                this.controls.update();
            }
            
            // Handle window resize
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Main animation loop
            animate() {
                requestAnimationFrame(this.animate);
                
                const deltaTime = Math.min(this.clock.getDelta(), 0.1);
                
                // Update player position
                this.updatePlayer(deltaTime);
                
                // Update water
                if (this.water) {
                    this.water.material.uniforms['time'].value += deltaTime;
                }
                
                // Day/night cycle
                if (this.parameters) {
                    this.parameters.azimuth += deltaTime * 1; // Slow day/night cycle
                    if (this.parameters.azimuth > 360) this.parameters.azimuth -= 360;
                    this.updateSun();
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            const world = new OpenWorld();
        });
        
        // Initialize immediately if DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                const world = new OpenWorld();
            });
        } else {
            const world = new OpenWorld();
        }
    </script>
</body>
</html>