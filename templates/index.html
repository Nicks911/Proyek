<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRAFKOMMMMMMM</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
    </script>
</head>
<body>
    <div id="info">WASD untuk bergerak, Mouse untuk melihat sekitar, F untuk flashlight, N untuk toggle malam/siang</div>
    <div id="compass" style="position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; background-color: rgba(0, 0, 0, 0.5); padding: 5px; border-radius: 5px;">
  Direction: -
</div>
    
    <script type="module">
        // Import Three.js dari CDN dengan path yang benar
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

        // Variabel global
        let scene, camera, renderer;
        let ground;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let velocity = new THREE.Vector3();
        let prevTime = performance.now();
        const speed = 50.0;

        // Deklarasikan variabel global untuk lampu dan status mode
        let ambientLight, directionalLight;
        let isNight = false;
        
        // Variabel untuk flashlight
        let flashlight;
        let isFlashlightOn = false;

        // Variabel untuk smooth camera movement
        let mouseEnabled = false;
        const mouseVelocity = new THREE.Vector2(0, 0);
        const mouseAcceleration = 0.1;
        const mouseDamping = 0.7;

        // Kontrol kamera
        const cameraRotation = new THREE.Euler(0, 0, 0, 'YXZ');
        
        // Variabel untuk collision detection
        const collisionObjects = [];
        const playerRadius = 5; // Radius collision player
        const playerHeight = 10; // Tinggi player (untuk staircase jika perlu)
        
        // Ray casting untuk collision
        const raycaster = new THREE.Raycaster();
        
        let isDriving = false;
        let carModel = null;  // Simpan referensi model mobil untuk mode mengemudi
        let carCollisionBox = null;

        let lastPlayerPosition = null;

        // Tambahkan di bagian deklarasi variabel global
        let leftHeadlight, rightHeadlight;

        // Tambahkan variabel global untuk bulan
        let moon;

        // Tambahkan variabel global untuk kecepatan mobil
        let carSpeed = 80; // default

        // Add these global variables at the top with other global declarations
let chaosEmerald = null;
let isEmeraldCollected = false;

        // Inisialisasi scene
        function init() {
            // Membuat scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Membuat kamera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1500); // Ubah dari 5000 ke 10000
            // Spawn player di X: -1163, Y: 10, Z: -8
            camera.position.set(-1141, 23, 191);
            camera.rotation.order = 'YXZ';
            
            // Inisialisasi cahaya dengan variabel global
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Directional light (matahari)
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            
            // Atur kualitas dan area shadow untuk directional light
            directionalLight.shadow.mapSize.width = 4096; // Tingkatkan resolusi shadow
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Setup flashlight dengan shadow yang lebih detail
            flashlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);
            flashlight.castShadow = true;
            flashlight.shadow.mapSize.width = 1024;
            flashlight.shadow.mapSize.height = 1024;
            flashlight.shadow.camera.near = 0.5;
            flashlight.shadow.camera.far = 100;
            flashlight.shadow.bias = -0.0001;
            scene.add(flashlight);
            scene.add(flashlight.target);
            
            // Setup headlights untuk mobil
            leftHeadlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);
            rightHeadlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);

            // Setup kedua headlight
            [leftHeadlight, rightHeadlight].forEach(light => {
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                light.shadow.camera.near = 0.5;
                light.shadow.camera.far = 100;
                light.shadow.bias = -0.0001;
                light.visible = false; // Nonaktifkan pada awalnya
                scene.add(light);
                scene.add(light.target);
            });
            
            // Membuat tanah
            createGround();
            
            // Tambahkan road 4 arah
            create4WayRoad();
            
            // Load model hospital
            loadHospitalModel();
            
            // Tambahkan streetlamp sepanjang ujung map
            //createStreetlamps();
            
            // Load model skyscraper
            loadSkyscraperModel();

            // Load model house
            loadHouseModel();

            // Tambahkan batas map untuk collision
            createMapBoundaries();
            
            // Load model car
            loadCarModel();
            
            // Load moon model
            const moonLoader = new GLTFLoader();
            moonLoader.load(
                '/model/moon_idle.glb',
                function (gltf) {
                    moon = gltf.scene;
                    moon.scale.set(5, 5, 5);
                    moon.position.set(-500, 700, 300);
                    
                    // Tambahkan point light untuk bulan
                    const moonLight = new THREE.PointLight(0xc2c5cc, 0.5, 1000);
                    moonLight.position.copy(moon.position);
                    moon.userData.moonLight = moonLight; // Simpan referensi ke moonLight
                    scene.add(moonLight);
                    
                    moon.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshPhongMaterial({
                                map: child.material.map,
                                emissive: 0xffffcc,
                                emissiveIntensity: 0.0, // Akan diubah saat mode malam
                                side: THREE.DoubleSide
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(moon);
                },
                undefined,
                function (error) {
                    console.error('Error loading moon:', error);
                }
            );
            
            // Setup renderer, event listener, dan animasi
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.darkness = 1; // Menambah kegelapan shadow
            document.body.appendChild(renderer.domElement);
            
            // Setup event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            
            // Tambahkan event listener untuk pointer lock
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mozpointerlockchange', onPointerLockChange);
            document.addEventListener('webkitpointerlockchange', onPointerLockChange);
            
            // Request pointer lock on click
            document.body.addEventListener('click', requestPointerLock);
            
            animate();
            loadCathedralModel();
            loadSmallBuildingModel();
            loadBakeryModel();
            loadHungryJacksModel();
            loadPoliceStationModel(); 
            loadWarehouseModel();
            loadStopSign();
            // Panggil fungsi loadTownHouseModel() di akhir init()
            loadTownHouseModel();
            loadBillboardModel();
            loadTungTung();
            loadFarmHouseModel();
            loadWelcomeBoardModel();
            loadOldBuildingModel();
            
            // Load Chaos Emerald model
            loadChaosEmeraldModel();
        }

        function createFlashlight() {
            // Buat SpotLight untuk flashlight
            flashlight = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI/4, 0.5, 1);
            
            // Setel posisi awal dan target spotlight
            flashlight.position.set(0, 0, 0);
            flashlight.target.position.set(0, 0, -1);
            
            // Mengaktifkan bayangan untuk flashlight
            flashlight.castShadow = true;
            flashlight.shadow.mapSize.width = 1024;
            flashlight.shadow.mapSize.height = 1024;
            
            // Nonaktifkan flashlight pada awalnya
            flashlight.visible = false;
            
            // Tambahkan flashlight dan targetnya ke scene
            scene.add(flashlight);
            scene.add(flashlight.target);
        }

        function toggleFlashlight() {
            isFlashlightOn = !isFlashlightOn;
            flashlight.visible = isFlashlightOn;
            // Opsional: tambahkan efek suara klik
            //playClickSound();
        }
        
        function playClickSound() {
            // Implementasi Web Audio API untuk efek suara klik
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(isFlashlightOn ? 800 : 600, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                console.error('Web Audio API tidak didukung:', e);
            }
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(2500, 800);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2E8B57,
                side: THREE.DoubleSide
            });
            
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Hapus atau komentari baris berikut untuk menghilangkan garis putih:
            // const gridHelper = new THREE.GridHelper(1000, 50);
            // scene.add(gridHelper);
        }

        // Fungsi untuk membuat bounding box pada objek 3D
        function createCollisionBox(object, offsetX = 0, offsetY = 0, offsetZ = 0, scaleX = 1, scaleY = 1, scaleZ = 1) {
            // Buat bounding box helper untuk visualisasi (opsional, dapat dikomentari untuk produksi)
            // const boxHelper = new THREE.BoxHelper(object, 0xff0000);
            // scene.add(boxHelper);
            
            // Hitung bounding box objek
            const bbox = new THREE.Box3().setFromObject(object);
            
            // Buat custom collision box dengan mesh tak terlihat
            const width = (bbox.max.x - bbox.min.x) * scaleX;
            const height = (bbox.max.y - bbox.min.y) * scaleY;
            const depth = (bbox.max.z - bbox.min.z) * scaleZ;
            
            const collisionGeometry = new THREE.BoxGeometry(width, height, depth);
            const collisionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                wireframe: true,
                visible: false // Set ke true untuk debugging
            });
            
            const collisionMesh = new THREE.Mesh(collisionGeometry, collisionMaterial);
            
            // Posisikan collision box di tengah objek + offset
            collisionMesh.position.set(
                (bbox.min.x + bbox.max.x) / 2 + offsetX,
                (bbox.min.y + bbox.max.y) / 2 + offsetY,
                (bbox.min.z + bbox.max.z) / 2 + offsetZ
            );
            
            scene.add(collisionMesh);
            collisionObjects.push(collisionMesh);
            
            return collisionMesh;
        }

        // Fungsi untuk membuat batas map (invisible walls)
        function createMapBoundaries() {
            // Karena ground 2500 x 1000, setengahnya:
            const mapWidth = 1250;  // setengah lebar ground (X)
            const mapHeight = 400;  // setengah panjang ground (Z)
            const wallHeight = 100;
            const wallThickness = 10;

            // Buat material transparan untuk dinding
            const wallMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.0, // Tidak terlihat
                side: THREE.DoubleSide
            });

            // Dinding Utara (Z negatif)
            const northWallGeometry = new THREE.BoxGeometry(mapWidth * 2, wallHeight, wallThickness);
            const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
            northWall.position.set(0, wallHeight / 2, -mapHeight);
            scene.add(northWall);
            collisionObjects.push(northWall);

            // Dinding Selatan (Z positif)
            const southWall = northWall.clone();
            southWall.position.set(0, wallHeight / 2, mapHeight);
            scene.add(southWall);
            collisionObjects.push(southWall);

            // Dinding Barat (X negatif)
            const westWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, mapHeight * 2);
            const westWall = new THREE.Mesh(westWallGeometry, wallMaterial);
            westWall.position.set(-mapWidth, wallHeight / 2, 0);
            scene.add(westWall);
            collisionObjects.push(westWall);

            // Dinding Timur (X positif)
            const eastWall = westWall.clone();
            eastWall.position.set(mapWidth, wallHeight / 2, 0);
            scene.add(eastWall);
            collisionObjects.push(eastWall);
        }

        async function loadHospitalModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/low_poly_hospital.glb');
                
                const hospital = gltf.scene;
                hospital.position.set(-216, 0.1, -229);
                hospital.scale.set(11, 11, 11);
                hospital.rotation.y = 0;
                
                hospital.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Tambahkan material properties untuk shadow yang lebih baik
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });
                
                scene.add(hospital);
                createCollisionBox(hospital, 0, 10, 0, 1, 1, 0.8);
            } catch (error) {
                console.error('Gagal memuat model rumah sakit:', error);
                createSimpleHospital();
            }
        }

        async function loadSkyscraperModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Skyscraper.glb');
                const skyscraper = gltf.scene;
                skyscraper.position.set(215, 0.1, -213);
                skyscraper.scale.set(200, 200, 200);
                skyscraper.rotation.y = Math.PI;

                skyscraper.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Tambahkan material properties untuk shadow yang lebih baik
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(skyscraper);
                createCollisionBox(skyscraper, 0, 10, 0, 1, 1, 1);
            } catch (error) {
                console.error('Gagal memuat model skyscraper:', error);
            }
        }

        async function loadHouseModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/House with driveway.glb');
                const house = gltf.scene;
                // Tempatkan house pada X: -1123, Z: 209
                house.position.set(-1139, 0.1, 220);
                house.scale.set(10, 10, 10); // Sesuaikan skala jika perlu
                house.rotation.y = Math.PI; // Rotasi jika perlu

                house.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                scene.add(house);

                // Tambahkan collision box untuk house jika perlu
                createCollisionBox(house, 0, 20, 0, 1, 1, 0.14);
            } catch (error) {
                console.error('Gagal memuat model house:', error);
            }
        }

        async function loadCarModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/1994_Nissan_180MX.glb');
                const car = gltf.scene;
                car.position.set(-1163, 13, -8);
                car.scale.set(6, 6, 6);
                car.rotation.y = Math.PI / 2;

                car.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Tambahkan material properties untuk shadow yang lebih baik
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(car);
                carModel = car;
                carCollisionBox = createCollisionBox(car, 0, 10, 0, 1, 1, 1);
            } catch (error) {
                console.error('Error loading car model:', error);
            }
        }

        function createSimpleHospital() {
            // Fallback: create a simple red box as a hospital model substitute
            const geometry = new THREE.BoxGeometry(1000, 10, 10);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const simpleHospital = new THREE.Mesh(geometry, material);
            simpleHospital.position.set(50, 5, 50);
            simpleHospital.castShadow = true;
            simpleHospital.receiveShadow = true;
            scene.add(simpleHospital);
            
            // Tambahkan collision untuk fallback hospital
            collisionObjects.push(simpleHospital);
        }

        function create4WayRoad() {
            const roadColor = 0x333333;
            const roadMaterial = new THREE.MeshStandardMaterial({ color: roadColor });
            const groundSize = 2500; // same size as the ground
            const roadWidth = 100; // road width
        
            // Horizontal road (along X axis)
            const horizontalGeometry = new THREE.PlaneGeometry(groundSize, roadWidth);
            const horizontalRoad = new THREE.Mesh(horizontalGeometry, roadMaterial);
            horizontalRoad.rotation.x = -Math.PI / 2;
            horizontalRoad.position.set(0, 0.11, 0);
        
            // Hapus/komentari bagian vertical road (arah north-south)
            // const verticalGeometry = new THREE.PlaneGeometry(roadWidth, groundSize);
            // const verticalRoad = new THREE.Mesh(verticalGeometry, roadMaterial);
            // verticalRoad.rotation.x = -Math.PI / 2;
            // verticalRoad.position.set(0, 0.11, 0);
        
            // Create a group to hold the road(s)
            const roadGroup = new THREE.Group();
            roadGroup.add(horizontalRoad);
            // Jangan tambahkan verticalRoad ke group
            // roadGroup.add(verticalRoad);
            roadGroup.position.set(0, 0, 0);
        
            scene.add(roadGroup);
        }
        function createSimpleStreetlamps() {
            const spacing = 150;
            const roadWidth = 100;
            const roadLength = 1000;
            const offsetFromRoadCenter = roadWidth / 2 + 5;
            
            // Create global array to manage streetlamp lights
            if (!window.streetLampLights) window.streetLampLights = [];
            
            // Create simple lamps on north side
            for (let x = -roadLength; x <= roadLength; x += spacing) {
                // Create lamp post (cylinder)
                const postGeometry = new THREE.CylinderGeometry(1, 1, 40, 8);
                const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(x, 20, -offsetFromRoadCenter);
                post.castShadow = true;
                scene.add(post);
                
                // Create lamp head (sphere)
                const headGeometry = new THREE.SphereGeometry(3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffeeaa,
                    emissive: 0xffeeaa,
                    emissiveIntensity: isNight ? 1.0 : 0.0
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(x, 48, -offsetFromRoadCenter); // Updated to Y=48 for correct lightbulb position
                head.userData.isLampBulb = true;
                scene.add(head);
                
                // Only add actual light to every 3rd lamp
                if (Math.abs(x) % (spacing * 3) === 0) {
                    const light = new THREE.PointLight(0xffeeaa, 1.5, 150);
                    light.position.set(x, 48, -offsetFromRoadCenter); // Updated to Y=48
                    light.visible = isNight;
                    light.castShadow = false;
                    scene.add(light);
                    window.streetLampLights.push(light);
                }
                
                // Add collision
                createCollisionBox(post, 0, 20, 0, 1, 1, 1);
            }
            
            // Create simple lamps on south side
            for (let x = -roadLength; x <= roadLength; x += spacing) {
                // Create lamp post (cylinder)
                const postGeometry = new THREE.CylinderGeometry(1, 1, 40, 8);
                const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(x, 20, offsetFromRoadCenter);
                post.castShadow = true;
                scene.add(post);
                
                // Create lamp head (sphere)
                const headGeometry = new THREE.SphereGeometry(3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffeeaa,
                    emissive: 0xffeeaa,
                    emissiveIntensity: isNight ? 1.0 : 0.0
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(x, 48, offsetFromRoadCenter); // Updated to Y=48 for correct lightbulb position
                head.userData.isLampBulb = true;
                scene.add(head);
                
                // Only add actual light to every 3rd lamp
                if (Math.abs(x) % (spacing * 3) === 0) {
                    const light = new THREE.PointLight(0xffeeaa, 1.5, 150);
                    light.position.set(x, 48, offsetFromRoadCenter); // Updated to Y=48
                    light.visible = isNight;
                    light.castShadow = false;
                    scene.add(light);
                    window.streetLampLights.push(light);
                }
                
                // Add collision
                createCollisionBox(post, 0, 20, 0, 1, 1, 1);
            }
        }

        async function createStreetlamps() {
            const streetlampPath = '/model/spherical_street_lamp.glb';
            const loader = new GLTFLoader();

            try {
                const gltf = await loader.loadAsync(streetlampPath);
                const baseLamp = gltf.scene;
                baseLamp.scale.set(20, 20, 20);

                const spacing = 150;
                const roadWidth = 100;
                const roadLength = 1000;
                const offsetFromRoadCenter = roadWidth / 2 + 5;
                
                // Create global array to manage streetlamp lights
                if (!window.streetLampLights) window.streetLampLights = [];
                
                // --- Lampu untuk sisi Utara (Z negatif) ---
                for (let x = -roadLength; x <= roadLength; x += spacing) {
                    let lampNorth = baseLamp.clone();
                    lampNorth.position.set(x, 0, -offsetFromRoadCenter);
                    lampNorth.rotation.y = Math.PI * 0.1/4;
                    scene.add(lampNorth);
                    createCollisionBox(lampNorth, 0, 10, 0, 0.2, 1, 0.2);

                    // Add a light bulb glow material to the lamp head
                    const lampHeadMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffeeaa,
                        emissive: 0xffeeaa,
                        emissiveIntensity: isNight ? 1.0 : 0.0
                    });
                    
                    // Find the lamp head mesh and apply the glowing material
                    lampNorth.traverse(child => {
                        if (child.isMesh && (child.name.toLowerCase().includes('bulb') || 
                            child.name.toLowerCase().includes('glass') || 
                            child.name.toLowerCase().includes('light'))) {
                            child.material = lampHeadMaterial;
                            child.userData.isLampBulb = true;
                        }
                    });
                    
                    // Only create actual lights for every 3rd lamp to reduce performance impact
                    if (Math.abs(x) % (spacing * 3) === 0) {
                        // Use point light with no shadows for better performance
                        const lampLight = new THREE.PointLight(0xffeeaa, 1.5, 150);
                        lampLight.position.set(x, 48, -offsetFromRoadCenter); // Updated to Y=48 for correct lightbulb position
                        lampLight.visible = isNight;
                        // Disable shadows for better performance
                        lampLight.castShadow = false;
                        
                        scene.add(lampLight);
                        window.streetLampLights.push(lampLight);
                    }
                }

                // --- Lampu untuk sisi Selatan (Z positif) ---
                for (let x = -roadLength; x <= roadLength; x += spacing) {
                    let lampSouth = baseLamp.clone();
                    lampSouth.position.set(x, 0, offsetFromRoadCenter);
                    lampSouth.rotation.y = -Math.PI * 0.1/4;
                    scene.add(lampSouth);
                    createCollisionBox(lampSouth, 0, 10, 0, 0.2, 1, 0.2);

                    // Add a light bulb glow material to the lamp head
                    const lampHeadMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffeeaa,
                        emissive: 0xffeeaa,
                        emissiveIntensity: isNight ? 1.0 : 0.0
                    });
                    
                    // Find the lamp head mesh and apply the glowing material
                    lampSouth.traverse(child => {
                        if (child.isMesh && (child.name.toLowerCase().includes('bulb') || 
                            child.name.toLowerCase().includes('glass') || 
                            child.name.toLowerCase().includes('light'))) {
                            child.material = lampHeadMaterial;
                            child.userData.isLampBulb = true;
                        }
                    });
                    
                    // Only create actual lights for every 3rd lamp to reduce performance impact
                    if (Math.abs(x) % (spacing * 3) === 0) {
                        // Use point light with no shadows for better performance
                        const lampLight = new THREE.PointLight(0xffeeaa, 1.5, 150);
                        lampLight.position.set(x, 48, offsetFromRoadCenter); // Updated to Y=48 for correct lightbulb position
                        lampLight.visible = isNight;
                        // Disable shadows for better performance
                        lampLight.castShadow = false;
                        
                        scene.add(lampLight);
                        window.streetLampLights.push(lampLight);
                    }
                }

            } catch (error) {
                console.error('Error loading streetlamp model:', error);
                createSimpleStreetlamps();
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyN': // Toggle mode malam/siang
                    isNight = !isNight;
                    toggleNightMode();
                    break;
                case 'KeyF': // Toggle flashlight
                    toggleFlashlight();
                    break;
                case 'KeyE':
            if (!isDriving && carModel) {
                // Hitung jarak hanya pada X dan Z
                const dx = camera.position.x - carModel.position.x;
                const dz = camera.position.z - carModel.position.z;
                const distanceXZ = Math.sqrt(dx*dx + dz*dz);
                
                console.log("Jarak ke mobil:", distanceXZ); // Untuk debugging
                
                if (distanceXZ < 30) { // Perbesar jarak deteksi
                    enterCar();
                } else {
                    console.log("Terlalu jauh dari mobil");
                }
            } else if (isDriving) {
                exitCar();
            }
            break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        // Fungsi ini dipanggil saat status pointer lock berubah
        function onPointerLockChange() {
            if (document.pointerLockElement === document.body ||
                document.mozPointerLockElement === document.body ||
                document.webkitPointerLockElement === document.body) {
                mouseEnabled = true;
            } else {
                mouseEnabled = false;
            }
        }

        // Fungsi untuk request pointer lock dengan cross-browser support
        function requestPointerLock() {
            if (!mouseEnabled) {
                const element = document.body;
                
                element.requestPointerLock = element.requestPointerLock ||
                                            element.mozRequestPointerLock ||
                                            element.webkitRequestPointerLock;
                
                element.requestPointerLock();
            }
        }

        // Update fungsi onMouseMove untuk smooth camera
        function onMouseMove(event) {
            if (!mouseEnabled) return;
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            // Batasi input maksimum untuk menghindari gerakan ekstrim
            const maxMovement = 15;
            const clampedMovementX = Math.max(Math.min(movementX, maxMovement), -maxMovement);
            const clampedMovementY = Math.max(Math.min(movementY, maxMovement), -maxMovement);
            
            // Gunakan acceleration yang lebih rendah untuk mouse movement
            mouseVelocity.x -= clampedMovementX * mouseAcceleration;
            mouseVelocity.y -= clampedMovementY * mouseAcceleration;
        }

        function toggleNightMode() {
            if (isNight) {
                // Mode malam: background gelap dan intensitas cahaya sangat rendah
                scene.background = new THREE.Color(0x000005); // Hampir hitam total
                ambientLight.intensity = 0.05; // Cahaya ambient sangat minim
                directionalLight.intensity = 0.1; // Cahaya directional juga minim
                directionalLight.position.set(-100, 50, -50); // Ubah posisi matahari untuk malam
                
                // Tambahkan fog untuk efek horror
                scene.fog = new THREE.FogExp2(0x000000, 0.0007); // Kurangi densitas fog
                
                // Turn on all streetlamp lights
                if (window.streetLampLights) {
                    window.streetLampLights.forEach(light => {
                        light.visible = true;
                        light.castShadow = true;
                    });
                }
                
                // Make all lamp bulbs glow
                scene.traverse(object => {
                    if (object.isMesh && object.userData.isLampBulb) {
                        if (object.material) {
                            object.material.emissiveIntensity = 1.0;
                        }
                    }
                });
                
                // Perbarui pencahayaan bulan
                if (moon) {
                    moon.traverse((child) => {
                        if (child.isMesh) {
                            child.material.emissiveIntensity = 1.0;
                        }
                    });
                    // Aktifkan moonLight
                    if (moon.userData.moonLight) {
                        moon.userData.moonLight.intensity = 0.8;
                    }
                }
                
                // Perbarui shadow settings untuk malam hari
                renderer.shadowMap.darkness = 0.8;
                directionalLight.shadow.bias = -0.0005;
                directionalLight.shadow.normalBias = 0.02;
                
                // Perbarui flashlight shadow settings
                [flashlight, leftHeadlight, rightHeadlight].forEach(light => {
                    if (light) {
                        light.shadow.bias = -0.0005;
                        light.shadow.normalBias = 0.02;
                        light.shadow.radius = 4; // Membuat shadow lebih lembut
                        light.penumbra = 0.5; // Membuat tepi cahaya lebih lembut
                    }
                });
                
            } else {
                // Kembali ke mode siang: background dan intensitas normal
                scene.background = new THREE.Color(0x87CEEB);
                ambientLight.intensity = 0.5;
                directionalLight.intensity = 0.8;
                directionalLight.position.set(100, 100, 50); // Ubah posisi matahari untuk siang
                scene.fog = null;
                
                // Turn off all streetlamp lights
                if (window.streetLampLights) {
                    window.streetLampLights.forEach(light => {
                        light.visible = false;
                        light.castShadow = false;
                    });
                }
                
                // Turn off lamp bulb glow
                scene.traverse(object => {
                    if (object.isMesh && object.userData.isLampBulb) {
                        if (object.material) {
                            object.material.emissiveIntensity = 0.0;
                        }
                    }
                });
                
                // Matikan pencahayaan bulan
                if (moon) {
                    moon.traverse((child) => {
                        if (child.isMesh) {
                            child.material.emissiveIntensity = 0.0;
                        }
                    });
                    // Nonaktifkan moonLight
                    if (moon.userData.moonLight) {
                        moon.userData.moonLight.intensity = 0;
                    }
                }
                
                // Reset shadow settings untuk siang hari
                renderer.shadowMap.darkness = 0.3;
                directionalLight.shadow.bias = -0.0001;
                directionalLight.shadow.normalBias = 0.01;
                
                [flashlight, leftHeadlight, rightHeadlight].forEach(light => {
                    if (light) {
                        light.shadow.bias = -0.0001;
                        light.shadow.normalBias = 0.01;
                        light.shadow.radius = 2;
                        light.penumbra = 0.2;
                    }
                });
            }
        }

        
        // Fungsi untuk efek flicker pada flashlight (opsional)
        function flickerFlashlight() {
            if (isFlashlightOn && Math.random() < 0.05) {
                const originalIntensity = flashlight.intensity;
                flashlight.intensity = originalIntensity * (0.5 + Math.random() * 0.5);
                setTimeout(() => {
                    flashlight.intensity = 100; // Restore ke nilai original dari createFlashlight()
                }, 50 + Math.random() * 100);
            }
        }

        // Fungsi untuk mendeteksi collision
        function checkCollision(position, radius) {
            // Cek untuk setiap collision object
            for (const object of collisionObjects) {
                // Dapatkan bounding box dari objek
                const bbox = new THREE.Box3().setFromObject(object);
                
                // Sphere-Box collision detection
                // Dapatkan point terdekat pada bbox ke position
                const closestPoint = new THREE.Vector3().copy(position);
                
                // Clamp closestPoint ke dalam bbox
                closestPoint.x = Math.max(bbox.min.x, Math.min(bbox.max.x, closestPoint.x));
                closestPoint.y = Math.max(bbox.min.y, Math.min(bbox.max.y, closestPoint.y));
                closestPoint.z = Math.max(bbox.min.z, Math.min(bbox.max.z, closestPoint.z));
                
                // Hitung jarak antara position dan closestPoint
                const distance = position.distanceTo(closestPoint);
                
                // Jika jarak kurang dari radius, artinya terjadi collision
                if (distance < radius) {
                    return {
                        collision: true,
                        object: object,
                        distance: distance,
                        normal: new THREE.Vector3().subVectors(position, closestPoint).normalize()
                    };
                }
            }
            
            // Tidak ada collision
            return { collision: false };
        }

        // Misal: cek collision berdasarkan jarak minimal dari setiap vertex ke posisi tertentu (misal, playerPosition)
        function checkCollisionPerVertex(mesh, playerPosition, collisionDistance) {
            // Pastikan geometry sudah di-update dan di-bake world matrix dari mesh
            mesh.updateMatrixWorld();
            const geometry = mesh.geometry;
            // Dapatkan array posisi vertex
            const positions = geometry.attributes.position.array;
            
            // Buat vector temporary untuk transformasi
            const vertexWorld = new THREE.Vector3();
            for (let i = 0; i < positions.length; i += 3) {
                vertexWorld.set(positions[i], positions[i+1], positions[i+2]);
                // Transform ke koordinat dunia
                vertexWorld.applyMatrix4(mesh.matrixWorld);
                
                // Lakukan pengecekan jarak antara vertex dengan playerPosition
                if (vertexWorld.distanceTo(playerPosition) < collisionDistance) {
                    return true; // Collision terdeteksi
                }
            }
            return false;
        }

        // Fungsi untuk memindahkan karakter dengan collision
        function moveWithCollision(moveVector) {
            // Posisi saat ini
            const currentPosition = camera.position.clone();
            
            // Posisi rencana setelah bergerak
            const plannedPosition = currentPosition.clone().add(moveVector);
            
            // Cek collision
            const result = checkCollision(plannedPosition, playerRadius);
            
            if (result.collision) {
                // Jika terjadi collision, geser posisi keluar dari collision
                const pushDistance = playerRadius - result.distance + 0.1; // Sedikit ekstra untuk safety
                const pushVector = result.normal.multiplyScalar(pushDistance);
                
                // Tambahkan pushVector ke planned position
                plannedPosition.add(pushVector);
                
                // Update moveVector berdasarkan new planned position
                moveVector.subVectors(plannedPosition, currentPosition);
                
                // Reset Y value agar player tidak terbang/terbenam
                moveVector.y = 0;
            }
            
            // Terapkan move vector ke posisi kamera
            camera.position.add(moveVector);
        }

        // Fungsi untuk mengecek collision mobil dengan objek lain
function checkCarCollisions(newPosition) {
    // Buat temporary box untuk simulasi posisi baru mobil
    const tempBox = new THREE.Box3();
    if (carCollisionBox) {
        tempBox.copy(new THREE.Box3().setFromObject(carCollisionBox));
        
        // Hitung offset dari posisi saat ini ke posisi baru
        const offsetX = newPosition.x - carModel.position.x;
        const offsetY = newPosition.y - carModel.position.y;
        const offsetZ = newPosition.z - carModel.position.z;
        
        // Pindahkan box ke posisi baru yang direncanakan
        tempBox.min.x += offsetX;
        tempBox.min.y += offsetY;
        tempBox.min.z += offsetZ;
        tempBox.max.x += offsetX;
        tempBox.max.y += offsetY;
        tempBox.max.z += offsetZ;
        
        // Cek collision dengan semua objek
        for (const object of collisionObjects) {
            // Skip collision check dengan collision box mobil sendiri
            if (object === carCollisionBox) continue;
            
            const objectBox = new THREE.Box3().setFromObject(object);
            if (tempBox.intersectsBox(objectBox)) {
                return true; // Collision terdeteksi
            }
        }
    }
    return false; // Tidak ada collision
}

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (isDriving && carModel) {
                // Ambil arah depan dan kanan dari kamera (hanya XZ)
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();

                // WASD untuk arah relatif kamera
                let driveDirection = new THREE.Vector3();
                if (moveForward) driveDirection.add(forward);
                if (moveBackward) driveDirection.sub(forward);
                if (moveLeft) driveDirection.sub(right);
                if (moveRight) driveDirection.add(right);
                driveDirection.normalize();

                // Hitung posisi yang direncanakan
                const plannedPosition = carModel.position.clone().addScaledVector(driveDirection, carSpeed * delta);

                // Cek collision sebelum memindahkan mobil
                if (!checkCarCollisions(plannedPosition)) {
                    // Tidak ada collision, update posisi mobil
                    carModel.position.copy(plannedPosition);

                    // Update posisi collision box mobil
                    if (carCollisionBox) {
                        carCollisionBox.position.copy(carModel.position);
                    }
                } else {
                    // Ada collision, mobil tidak bergerak
                    console.log("Car collision detected!");
                }

                // --- Tambahkan rotasi mobil saat belok ---
    // Hanya rotasi jika ada input kiri/kanan
    if (moveLeft || moveRight) {
        // Tentukan arah rotasi: kiri negatif, kanan positif
        let turnDirection = 0;
        if (moveLeft) turnDirection -= 1;
        if (moveRight) turnDirection += 1;

        // Atur kecepatan rotasi (radian per detik)
        const turnSpeed = 1.5; // semakin besar semakin cepat belok

        // Update rotasi Y mobil
        carModel.rotation.y -= turnDirection * turnSpeed * delta;
    }

                updateCarCamera();
            } else {
                // Mode berjalan: update rotasi dan posisi kamera berdasarkan input mouse dan collision (kode existing Anda)
                if (mouseEnabled) {
                    mouseVelocity.x *= mouseDamping;
                    mouseVelocity.y *= mouseDamping;
                    if (Math.abs(mouseVelocity.x) < 0.001) mouseVelocity.x = 0;
                    if (Math.abs(mouseVelocity.y) < 0.001) mouseVelocity.y = 0;
                    cameraRotation.y += mouseVelocity.x * delta * 1.5;
                    cameraRotation.x += mouseVelocity.y * delta * 1.5;
                    cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                    camera.rotation.x = cameraRotation.x;
                    camera.rotation.y = cameraRotation.y;
                }
                
                // Update pergerakan player dan collision
                let moveDirection = new THREE.Vector3();
                if (moveForward) moveDirection.z += 1;
                if (moveBackward) moveDirection.z -= 1;
                if (moveLeft) moveDirection.x -= 1;
                if (moveRight) moveDirection.x += 1;
                moveDirection.normalize();

                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();
                const move = new THREE.Vector3();
                move.addScaledVector(forward, moveDirection.z * speed * delta);
                move.addScaledVector(right, moveDirection.x * speed * delta);
                
                moveWithCollision(move);
            }
            
            // Update flashlight, kompas, dll.
            if (isFlashlightOn) {
                const forwardDirection = new THREE.Vector3();
                camera.getWorldDirection(forwardDirection);
                
                if (isDriving && carModel) {
                    // Saat driving mode, tempatkan flashlight di depan mobil
                    const offsetY = 5; // Ketinggian lampu dari tanah
                    const offsetZ = 20; // Jarak lampu dari depan mobil
                    
                    // Gunakan posisi mobil sebagai referensi
                    flashlight.position.copy(carModel.position);
                    flashlight.position.y += offsetY;
                    flashlight.position.x += 20; // Sesuaikan dengan arah mobil (ke arah X positif)
                    
                    // Arahkan flashlight ke depan mobil
                    const targetDistance = 30;
                    flashlight.target.position.copy(flashlight.position);
                    flashlight.target.position.x += targetDistance;
                    flashlight.target.updateMatrixWorld();
                } else {
                    // Mode berjalan normal (kode yang sudah ada)
                    const offsetY = -1;
                    flashlight.position.copy(camera.position);
                    flashlight.position.y += offsetY;
                    const targetDistance = 10;
                    flashlight.target.position.copy(camera.position).add(forwardDirection.multiplyScalar(targetDistance));
                    flashlight.target.position.y += offsetY;
                    flashlight.target.updateMatrixWorld();
                }
            }
            
            // Update flashlight untuk lampu mobil
            if (isFlashlightOn) {
                if (isDriving && carModel) {
                    // Nonaktifkan flashlight utama saat driving
                    flashlight.visible = false;

                    // Offset headlight relatif terhadap posisi mobil
                    const offsetY = 5; // Ketinggian lampu
                    const offsetX = 5; // Jarak horizontal antar lampu
                    const forwardOffset = 25.8; // Jarak ke depan dari mobil

                    // Ambil arah depan mobil dari rotasi mobil
                    const carForward = new THREE.Vector3(0, 0, 1).applyEuler(carModel.rotation).normalize();
                    const carRight = new THREE.Vector3(1, 0, 0).applyEuler(carModel.rotation).normalize();

                    // Posisi headlight kiri
                    leftHeadlight.position.copy(carModel.position)
                        .add(carForward.clone().multiplyScalar(forwardOffset))
                        .add(carRight.clone().multiplyScalar(-offsetX))
                        .add(new THREE.Vector3(0, offsetY, 0));
                    leftHeadlight.visible = true;

                    // Posisi headlight kanan
                    rightHeadlight.position.copy(carModel.position)
                        .add(carForward.clone().multiplyScalar(forwardOffset))
                        .add(carRight.clone().multiplyScalar(offsetX))
                        .add(new THREE.Vector3(0, offsetY, 0));
                    rightHeadlight.visible = true;

                    // Target headlight ke depan mobil
                    const targetDistance = 30;
                    leftHeadlight.target.position.copy(leftHeadlight.position).add(carForward.clone().multiplyScalar(targetDistance));
                    rightHeadlight.target.position.copy(rightHeadlight.position).add(carForward.clone().multiplyScalar(targetDistance));
                    leftHeadlight.target.updateMatrixWorld();
                    rightHeadlight.target.updateMatrixWorld();
                } else {
                    // Mode berjalan normal
                    const offsetY = -1;
                    const offsetX = 10;
                    flashlight.position.copy(camera.position);
                    flashlight.position.y += offsetY;
                    flashlight.position.x += offsetX;
                    const targetDistance = 10;
                    const forwardDirection = new THREE.Vector3();
                    camera.getWorldDirection(forwardDirection);
                    flashlight.target.position.copy(camera.position).add(forwardDirection.multiplyScalar(targetDistance));
                    flashlight.target.position.y += offsetY;
                    flashlight.target.position.x += offsetX;
                    flashlight.target.updateMatrixWorld();
                    
                    // Nonaktifkan headlight mobil
                    leftHeadlight.visible = false;
                    rightHeadlight.visible = false;
                }
            } else {
                // Nonaktifkan semua lampu
                leftHeadlight.visible = false;
                rightHeadlight.visible = false;
            }
            
            // Putar bulan perlahan
            if (moon) {
                moon.rotation.y += 0.001;
            }
            
            updateCompass();
            
            prevTime = time;
            renderer.render(scene, camera);
            
            const infoEl = document.getElementById('info');
            infoEl.innerHTML = `WASD untuk bergerak, Mouse untuk melihat sekitar, F untuk flashlight, N untuk toggle malam/siang, E untuk masuk/keluar mobil<br>
            Kamera Posisi: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`;
        }

        init();

        function updateCompass() {
            // Dapatkan rotasi kamera (hanya yaw, pitch tidak dipakai)
            let yawDeg = THREE.MathUtils.radToDeg(camera.rotation.y);
            // Normalisasi ke [0, 360)
            yawDeg = (yawDeg % 360 + 360) % 360;
            
            let cardinal = '';
            if (yawDeg >= 337.5 || yawDeg < 22.5) {
                cardinal = 'N';
            } else if (yawDeg >= 22.5 && yawDeg < 67.5) {
                cardinal = 'NE';
            } else if (yawDeg >= 67.5 && yawDeg < 112.5) {
                cardinal = 'E';
            } else if (yawDeg >= 112.5 && yawDeg < 157.5) {
                cardinal = 'SE';
            } else if (yawDeg >= 157.5 && yawDeg < 202.5) {
                cardinal = 'S';
            } else if (yawDeg >= 202.5 && yawDeg < 247.5) {
                cardinal = 'SW';
            } else if (yawDeg >= 247.5 && yawDeg < 292.5) {
                cardinal = 'W';
            } else if (yawDeg >= 292.5 && yawDeg < 337.5) {
                cardinal = 'NW';
            }
            
            // Update tampilan kompas
            document.getElementById('compass').innerText = 'Direction: ' + cardinal;
        }

        // Tambahkan variabel global untuk tracking first time entering car
        let firstTimeEnteringCar = true;

        // Update fungsi enterCar()
        function enterCar() {
            isDriving = true;
            // Simpan posisi kamera player sebelum masuk mobil
            lastPlayerPosition = camera.position.clone();

            // Set kecepatan mobil lebih tinggi saat driving mode
            carSpeed = 80; // misal 250, bisa diubah sesuai keinginan

            // Check if this is first time entering car
            if (firstTimeEnteringCar) {
                firstTimeEnteringCar = false; // Set flag to false
                if (!isNight) { // Only toggle if not already night
                    isNight = true;
                    toggleNightMode();
                }
            }

            updateCarCamera();
            console.log("Masuk mode mengemudi");
        }

        function exitCar() {
            isDriving = false;

            // Kembalikan kecepatan ke default saat keluar mobil
            carSpeed = 80;

            // Simpan referensi ke rotasi mobil
            const carDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(carModel.quaternion);
            
            // Tempatkan pemain di belakang mobil (relatif terhadap orientasi mobil)
            const offset = carDirection.clone().multiplyScalar(-20); // 20 unit di belakang mobil
            
            // Tempatkan player di belakang mobil, sedikit lebih tinggi
            const newPosition = carModel.position.clone().add(offset).add(new THREE.Vector3(0, 10, 0));
            camera.position.copy(newPosition);
            
            // Hadapkan pemain ke arah mobil
            camera.lookAt(carModel.position);
            
            // Perbarui rotasi kamera agar sesuai dengan lookAt
            cameraRotation.y = camera.rotation.y;
            cameraRotation.x = camera.rotation.x;
            
            // Perbarui lastPlayerPosition
            lastPlayerPosition = newPosition.clone();
            
            console.log("Keluar mode mengemudi");
        }

        function updateCarCamera() {
            // Kamera mengikuti posisi dan rotasi mobil
            if (!carModel) return;

            // Offset kamera di atas dan sedikit di belakang mobil
            const cameraOffset = new THREE.Vector3(0, 20, -40); // Y = atas, Z = belakang
            // Transform offset ke ruang dunia sesuai rotasi mobil
            const worldOffset = cameraOffset.applyMatrix4(new THREE.Matrix4().makeRotationY(carModel.rotation.y));
            camera.position.copy(carModel.position).add(worldOffset);

            // Kamera menghadap ke arah depan mobil
            const lookAtOffset = new THREE.Vector3(0, 10, 40); // Y = sedikit atas, Z = depan
            const worldLookAt = lookAtOffset.applyMatrix4(new THREE.Matrix4().makeRotationY(carModel.rotation.y));
            camera.lookAt(carModel.position.clone().add(worldLookAt));
        }

        async function loadCathedralModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Cathedral.glb');
                const cathedral = gltf.scene;
                // Tempatkan cathedral pada X: -1137, Z: -155
                cathedral.position.set(-1110, 0.1, -155);
                cathedral.scale.set(20, 20, 20); // Sesuaikan skala jika perlu
                cathedral.rotation.y = Math.PI; // Rotasi jika perlu

                cathedral.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(cathedral);

                // Tambahkan collision box untuk cathedral
                createCollisionBox(cathedral, 0, 10, 0, 1, 1, 1); // Perbesar collision jika perlu
            } catch (error) {
                console.error('Gagal memuat model cathedral:', error);
            }
        }

        async function loadSmallBuildingModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Small Building.glb');
                const smallBuilding = gltf.scene;
                // Tempatkan small building pada X: -911, Z: 215
                smallBuilding.position.set(-850, 0.1, 140);
                smallBuilding.scale.set(150, 150, 150); // Sesuaikan skala jika perlu
                smallBuilding.rotation.y = 0; // Rotasi jika perlu

                smallBuilding.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(smallBuilding);

                // Tambahkan collision box untuk small building
                createCollisionBox(smallBuilding, 0, 10, 0, 1, 1, 1); // Perbesar collision jika perlu
            } catch (error) {
                console.error('Gagal memuat model small building:', error);
            }
        }

        async function loadBakeryModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/Bakery.glb');
                const familymart = gltf.scene;
                // Tempatkan Familymart pada X: -828, Z: -174
                familymart.position.set(-557, 0.1, 113);
                familymart.scale.set(9, 9, 9); // Sesuaikan skala jika perlu
                familymart.rotation.y = Math.PI; // Rotasi jika perlu

                familymart.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(familymart);

                // Tambahkan collision box untuk Familymart
                createCollisionBox(familymart, 0, 10, 0, 1, 1, 1); // Perbesar collision jika perlu
            } catch (error) {
                console.error('Gagal memuat model Familymart:', error);
            }
        }

        async function loadHungryJacksModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/hungryjacks.glb');
                const supermarket = gltf.scene;
                // Tempatkan supermarket pada X: -427, Z: 171
                supermarket.position.set(-680, 1, -245);
                supermarket.scale.set(8.5, 8.5, 8.5); // Sesuaikan skala jika perlu
                supermarket.rotation.y = 0; // Rotasi jika perlu

                supermarket.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(supermarket);

                // Tambahkan collision box untuk supermarket
                createCollisionBox(supermarket, 0, 10, 0, 1, 1, 1);
            } catch (error) {
                console.error('Gagal memuat model supermarket:', error);
            }
        }

        async function loadPoliceStationModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/police_station.glb');
                const policeStation = gltf.scene;
                // Posisikan police station di lokasi yang sesuai
                policeStation.position.set(300, 0.1, 210); // Sesuaikan koordinat sesuai kebutuhan
                policeStation.scale.set(3.1,3.1,3.1); // Sesuaikan skala sesuai kebutuhan
                policeStation.rotation.y = Math.PI; // Sesuaikan rotasi sesuai kebutuhan

                policeStation.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(policeStation);

                // Tambahkan collision box
                createCollisionBox(policeStation, 0, 10, 0, 0.7, 0.7, 0.7);
            } catch (error) {
                console.error('Gagal memuat model police station:', error);
            }
        }

        async function loadWarehouseModel() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/asia_building.glb');
                const warehouse = gltf.scene;
                
                // Posisikan warehouse di lokasi yang sesuai
                warehouse.position.set(-140, 0.1, 212);
                warehouse.scale.set(2.2, 2.2, 2.2);
                warehouse.rotation.y = Math.PI;

                warehouse.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(warehouse);

                // Mengecilkan collision box dengan mengubah parameter scaling
                createCollisionBox(warehouse, 0, 10, 0, 1, 1, 1); // Ubah nilai scaling menjadi lebih kecil
            } catch (error) {
                console.error('Gagal memuat model warehouse:', error);
            }
        }

        async function loadStopSign() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('/model/stop_sign.glb');
                const stopsign = gltf.scene;
                
                // Posisikan stopsign di lokasi yang sesuai
                stopsign.position.set(-330.94, 40, 88.23);
                stopsign.scale.set(1, 2, 1);
                stopsign.rotation.y = Math.PI + 0.66;

                stopsign.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.shadowSide = THREE.FrontSide;
                        }
                    }
                });

                scene.add(stopsign);

                // Mengecilkan collision box dengan mengubah parameter scaling
                createCollisionBox(stopsign, 0, 10, 0, 1, 1, 1); // Ubah nilai scaling menjadi lebih kecil
            } catch (error) {
                console.error('Gagal memuat model stopsign:', error);
            }
        }

        // Tambahkan fungsi berikut di bawah loadStopSign()
async function loadTownHouseModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/Town House.glb');
        const townHouse = gltf.scene;
        // Tempatkan Town House pada X: 473, Z: -223
        townHouse.position.set(550, 0.1, -135);
        townHouse.scale.set(45, 45, 55); // Sesuaikan skala jika perlu
        townHouse.rotation.y = 0; // Rotasi jika perlu

        townHouse.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(townHouse);

        // Tambahkan collision box untuk Town House
        createCollisionBox(townHouse, 0, 10, 0, 1, 1, 1);
    } catch (error) {
        console.error('Gagal memuat model Town House:', error);
    }
}

async function loadBillboardModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/abandoned_billboard.glb');
        const billboard = gltf.scene;
        
        // Position the billboard appropriately
        billboard.position.set(1167.03, 0.1, -139.73); // Adjust coordinates as needed
        billboard.scale.set(50, 50, 50); // Adjust scale as needed
        billboard.rotation.y = Math.PI - 1.2; // Adjust rotation as needed

        billboard.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(billboard);

        // Add collision box - using smaller values since it's a thin structure
        createCollisionBox(billboard, 0, 5, 0, 0.3, 0.8, 0.1);
    } catch (error) {
        console.error('Failed to load billboard model:', error);
    }
}

async function loadTungTung() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/tung_tung_tung_sahur_for_horror_free_download.glb');
        const horrorAudio = gltf.scene;
        
        // Position the horror audio model appropriately
        horrorAudio.position.set(363.46, 0.1, -79.52); // Adjust coordinates as needed
        horrorAudio.scale.set(15, 15, 15); // Adjust scale as needed
        horrorAudio.rotation.y = (Math.PI) + 1.2; // Adjust rotation as needed

        horrorAudio.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(horrorAudio);

        // Add collision box with small footprint
        createCollisionBox(horrorAudio, 0, 5, 0, 0.2, 0.8, 0.2);
    } catch (error) {
        console.error('Failed to load horror audio model:', error);
    }
}

async function loadFarmHouseModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/Farm house.glb');
        const farmHouse = gltf.scene;
        
        // Position the farm house appropriately
        farmHouse.position.set(800, 0.1, 200); // Adjust coordinates as needed
        farmHouse.scale.set(12, 12, 12); // Adjust scale as needed
        farmHouse.rotation.y = Math.PI; // Adjust rotation as needed

        farmHouse.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(farmHouse);

        // Add collision box with appropriate size
        createCollisionBox(farmHouse, 0, 10, 0, 0.8, 1, 0.8);
    } catch (error) {
        console.error('Failed to load farm house model:', error);
    }
}

async function loadWelcomeBoardModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/malaysia_road_sign.glb');
        const welcomeBoard = gltf.scene;
        
        // Position the welcome board
        welcomeBoard.position.set(-423.31, 0.1, -245.07); // Adjust coordinates as needed
        welcomeBoard.scale.set(75, 75, 155); // Adjust scale as needed
        welcomeBoard.rotation.y = 0; // Adjust rotation as needed

        welcomeBoard.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(welcomeBoard);

        // Add collision box - using thinner values since it's a gate structure
        createCollisionBox(welcomeBoard, 0, 10, 0, 0, 0, 0);
    } catch (error) {
        console.error('Failed to load welcome board model:', error);
    }
}

async function loadOldBuildingModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/old_building__lowpoly.glb');
        const oldBuilding = gltf.scene;
        
        // Position the old building
        oldBuilding.position.set(550, 0.1, 200); // Adjust coordinates as needed
        oldBuilding.scale.set(20, 20, 20); // Adjust scale as needed
        oldBuilding.rotation.y = Math.PI / 2; // Adjust rotation as needed

        oldBuilding.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                }
            }
        });

        scene.add(oldBuilding);

        // Add collision box with appropriate size
        createCollisionBox(oldBuilding, 0, 10, 0, 0.8, 1, 0.8);
    } catch (error) {
        console.error('Failed to load old building model:', error);
    }
}

// Add this function to load the Chaos Emerald
async function loadChaosEmeraldModel() {
    try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync('/model/chaos_emerald_-_sonic_the_hedgehog.glb');
        chaosEmerald = gltf.scene;
        
        // Position the emerald
        chaosEmerald.position.set(0, 5, 0); // Adjust position as needed
        chaosEmerald.scale.set(5, 5, 5); // Adjust scale as needed

        // Add rotating animation
        chaosEmerald.rotation.y = 0;

        // Make it emit light
        const emeraldLight = new THREE.PointLight(0x00ff00, 2, 50);
        emeraldLight.position.set(0, 0, 0);
        chaosEmerald.add(emeraldLight);

        chaosEmerald.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.shadowSide = THREE.FrontSide;
                    // Add some emission for glow effect
                    child.material.emissive = new THREE.Color(0x00ff00);
                    child.material.emissiveIntensity = 0.5;
                }
            }
        });

        scene.add(chaosEmerald);

    } catch (error) {
        console.error('Failed to load Chaos Emerald model:', error);
    }
}

// Add this function to check for emerald collection
function checkEmeraldCollection() {
    if (!isEmeraldCollected && chaosEmerald) {
        const playerPosition = isDriving ? carModel.position : camera.position;
        const distance = playerPosition.distanceTo(chaosEmerald.position);
        
        // Collection radius - adjust as needed
        const collectionRadius = 10;
        
        if (distance < collectionRadius) {
            // Collect the emerald
            isEmeraldCollected = true;
            scene.remove(chaosEmerald);
            
            // Add collection effect/sound if you want
            console.log("Chaos Emerald collected!");
            
            // Optional: Add some visual feedback
            const flashEffect = new THREE.PointLight(0x00ff00, 5, 100);
            flashEffect.position.copy(chaosEmerald.position);
            scene.add(flashEffect);
            
            // Remove the flash effect after a short delay
            setTimeout(() => {
                scene.remove(flashEffect);
            }, 500);
        }
    }
}

// Add these lines in your animate() function, before the renderer.render() call:
checkEmeraldCollection();
    </script>
</body>
</html>